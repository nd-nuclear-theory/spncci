/****************************************************************
  transform_basis.h

  Code to generate spncci basis transformations
                                  
  Anna E. McCoy
  TRIUMF

  SPDX-License-Identifier: MIT

  7/11/18 (aem): Created.
****************************************************************/

#ifndef SPNCCI_TRANSFORM_BASIS_H_
#define SPNCCI_TRANSFORM_BASIS_H_

#include <iostream>
#include <string>

#include "fmt/format.h"
#include "spncci/hyperblocks_u3s.h"
#include "spncci/parameters.h"

namespace spncci
{

void RegroupIntoIrrepFamilies(
    const std::vector<spncci::SpaceSpBasis>& spaces_spbasis,
    int num_irrep_families,
    int num_eigenvalues,
    const std::vector<spncci::Matrix>& eigenvectors,
    std::vector<std::vector<spncci::OperatorBlocks>>& irrep_family_blocks
  );
  // Regroup eigenvectors into blocks organzied by irrep family.  Within each block, 
  // columns correspond to different irreps with same Sp(3,R)SpSnS labels. Rows are
  // individual states within each Sp(3,R)SpSnS irrep.  Dimensions are thus 
  // [Dim(Sp(3,R)xS),gamma_max]
  //
  // input:
  //  spaces_spbasis: vector of spncci::SpaceSpBasis spaces, where each space
  //      is defined for a particular J value.  Index of space in spaces_spbasis
  //      corresponds to index of J in vector containing J values (J_values)
  //
  //  num_irrep_families: number of different irrep families, which are subspaces 
  //      defined by states with same Sp(3,R)SpSnS labels
  //
  //  num_eigenvalues: How many eigenstates of each J to regroup into irrep familiy blocks 
  //  
  //  eigenvectors: Vectors obtained from diagonalizing the Hamiltonian matrix
  //
  // output:
  //  irrep_family_blocks: array of blocks containing eigenvectors regrouped by irrep family
  //      within array, blocks are organized by J, by eigenvector index, by irrep family index



  void WriteIrrepFamilyBlocks(
    std::vector<HalfInt> J_values,  
    int num_irrep_families,
    int num_eigenvalues,
    const std::vector<int>& lgi_full_space_index_lookup,
    const std::vector<std::vector<spncci::OperatorBlocks>>& irrep_family_blocks,
    const std::string& filename
  );
// Write irrep family blocks to file
//
// In file:
//		<float precision, num_J_values, num_eigenvalues, num_irrep_families>
// 		
// 		For each irrep family,
// 			For each J value,
//				<2J, rows, cols>
//				For each n
//					<block(gamma_max,dim)>
//					

void ReadIrrepFamilyBlocks(
  std::map<int,std::vector<spncci::OperatorBlocks>>& irrep_family_blocks,
	std::map<int,std::map<int,int>>& J_index_lookup_table,
  const std::string& filename
);
// Read in Irrep family blocks that were generated in RegroupIntoIrrepFamilies and written to file by 
// WriteIrrepFamilyBlocks.
//
// Input:
//  irrep_family_blocks: array of blocks containing eigenvectors regrouped by irrep family
//      within array, blocks are organized by J, by eigenvector index, by irrep family index
//
//  J_index_lookup_table : Lookup table where key is irrep_family_index (full space index)
//      and value is lookup table (2J,j_index), where j_index corresponds to the index of J
//      from original J_values vector which defined the spaces_spbasis in RegroupIntoIrrepFamilies
//
//      Table only contains a 2J value for a given irrep_family_index if that irrep_family branched
//      to that J value.
//
//  filename: Name of file containing blocks and information on blocks

void  DefineIrrepFamilyTransformations(
  const std::vector<std::pair<int,int>>& Jn_set,
  std::map<int,std::vector<spncci::OperatorBlocks>>& irrep_family_blocks,
  std::map<int,std::map<int,int>>& J_index_lookup_table,
  const std::pair<std::string,double>& truncation_mode,
  spncci::OperatorBlocks& transformations
);
// Define rotation on LGI space based on eigenvectors for a given set of Jn pairs
//
// input:
//  Jn_set : vector of pairs of (2J,n) which are to be used in defining the 
//      unitary transformation
// 
//  irrep_family_blocks : array of blocks containing eigenvectors regrouped by irrep family
//      within array, blocks are organized by J, by eigenvector index, by irrep family index
//      Array is generated by RegroupIntoIrrepFamilies.
//
//  J_index_lookup_table : Lookup table where key is irrep_family_index (full space index)
//      and value is lookup table (2J,j_index), where j_index corresponds to the index of J
//      from original J_values vector which defined the spaces_spbasis in RegroupIntoIrrepFamilies
//
//      Table only contains a 2J value for a given irrep_family_index if that irrep_family branched
//      to that J value.
//      
//      Table is constructed in ReadIrrepFamilyBlocks
//  
//  truncation mode : How to define truncation of LGI subspaces.  Options are:
//       <"None",""> : keep the full matrix
//       <"Rank",""> : keep as many rows as there are ranks of svd decomposition
//       <"Threshold",value> : iterate over rows of transformed block and compute 
//                  sum values squared. If sum > value, keep row. 
//
// output:
//  transformations : matrix defining unitary transformation combined with truncation to be applied to lgi

void WriteTransformationMatrices(
  const spncci::OperatorBlocks& transformations,
  const std::string& filename
);
// <float_precision>
// for each irrep_family 
// 		<irrep_family_index, gamma_max, transformation matrix>
// ...

void WriteTruncatedLGIs(
    // const lgi::MultiplicityTaggedLGIVector& lgi_families,
    const std::array<int,2>& nuclide,
    // int Nsmax, int Nmax, int truncation_file_num,
    const spncci::OperatorBlocks& transformations,
    const std::string& truncated_lgi_filename
  );
// write truncated set of lgi familes to file
//    lgi_families_truncated_Nsigma,max_Nmax_index.dat


void ReadTransformationMatrices(  
	const std::string& filename,
  spncci::OperatorBlocks& transformations
);

void  RegroupBlocks(
  const std::vector<std::pair<int,int>>& Jn_set,
  const std::vector<spncci::OperatorBlocks>& blocks,
  std::map<int,int>& J_index_table,
  spncci::OperatorBlock& irrep_family_block
);
//Regroup different Jn blocks for a given irrep family into a single block 
//which is gamma_max x sum(Jn_subspaces)


void TransformSeeds(
  int bra_index,int ket_index,
  spncci::OperatorBlocks& transformations,
  basis::OperatorBlocks<double>& unit_tensor_seed_blocks
  );



}

#endif