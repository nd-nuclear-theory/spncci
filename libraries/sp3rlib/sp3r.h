/****************************************************************
  sp3r.h

  Sp(3,R) labeling and branching.
                                  
  Anna E. McCoy and Mark A. Caprio
  University of Notre Dame

  3/9/16 (aem,mac): Created based on prototype spstates.py, sp3r.py,
    and coefficients.py.
  2/1/17 (mac): Rename DebugString to DebugStr.
  7/1/17 (aem): Add modified branching rule for sp3r->u3 for A<6
****************************************************************/

#ifndef SP3R_H_
#define SP3R_H_

#include <map>
#include <string>
    
#include "basis/basis.h"
#include "sp3rlib/u3.h"

namespace sp3r 
{

  ////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////
  // Sp(3,R) irrep (space) -> U(3) irrep (subspace)
  ////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////

  // space labels: sigma (u3::U3)
  // space truncation: Nn,max (integer)
  // subspace labels: omega (u3::U3)
  // state labels within subspace: n (u3::U3), rho (integer)
  //
  // Within a space, the subspaces are ordered by:
  //   -- "canonically" increasing omega
  //
  // Within a subspace, the states are ordered by:
  //   -- "canonically" increasing n
  //      which is defined for us as lexicographical by N(lambda,mu)
  //   -- numerically increasing rho

  // container for all state labels generated in Sp(3,R) branching
  //    for use as input parameter to U3Subspace::Init()
  typedef std::multimap< u3::U3, MultiplicityTagged<u3::U3> > SpanakopitaType;
  typedef std::pair< SpanakopitaType::iterator, SpanakopitaType::iterator > SpanakopitaRangeType;

  // raising polynomial enumeration
  std::vector<u3::U3> RaisingPolynomialLabels(int Nn_max);
  //
  // Generate full set of raising polynomial U3 labels up to given Nn_max.
  //
  // Labels are generated in "canonical" order, defined as
  // lexicographic by N(lambda,mu).
  //
  // Arguments:
  //   Nn_max (int) : maximum excitation quanta of raising polynomial 
  //     labels
  //
  // Returns:
  //   (vector<u3::U3) : vector of raising polynomial labels

  double CCoef(u3::U3& n, int q, u3::U3& np);
  // Coefficient of fractional parentage for expanding the raising polynomial into a
  // polynomial of a single Jacobi coordinate and a polynomial of all other coordinates 
  // To be finished later if needed

  double BCoef(u3::U3& n1, u3::U3& n2, u3::U3& n3, int rho);
  // Polynomial product coefficients 
  // To be finished later if needed 

  typedef std::tuple<u3::U3,u3::U3,u3::U3,int> BCoefLabels;
  typedef std::map<BCoefLabels,double> BCoefCache;

  void GenerateBCoefCache(BCoefCache& cache, int Nmax);
  // Generates a cache of B coefficients needed for constructing 
  // symplectic raising polynomials 

  ////////////////////////////////////////////////////////////////
  // U(3) subspace
  ////////////////////////////////////////////////////////////////

  class U3Subspace
    : public basis::BaseSubspace< u3::U3 , MultiplicityTagged<u3::U3> >
    // subspace label type: u3::U3
    // state label type: MultiplicityTagged<u3::U3>
  {
    
  public:

    // constructor

    U3Subspace(const u3::U3& omega);
    // Construct U(3) subspace.
    //
    // This is a lightweight constructor which only stores the labels,
    // without populating the subspace with states.
    //
    // Arguments:
    //   omega (u3::U3) : labels for subspace

    void Init(const SpanakopitaRangeType& state_range);
    // Populate subspace
    //
    // Arguments:
    //   state_range (SpanakopitaRangeType) : begin and end
    //     iterators for states in include in subspace
    //
    // The states container contains all generated states as a
    // multimap, with key-value pairs omega -> (n,rho_max).  The
    // states are thus grouped and sorted by omega.  Only rho_max is
    // stored in the multimap, but the full rho set (1,...,rho_max)
    // will be enumerated in the subspace state listing generated by
    // this constructor.

    // accessors
    const u3::U3& U3() const
    {
      return labels_;
    }

    // diagnostic output
    std::string DebugStr() const;

  };

  ////////////////////////////////////////////////////////////////
  // Sp(3,R) space
  ////////////////////////////////////////////////////////////////

  class Sp3RSpace
    : public basis::BaseSpace<U3Subspace>
    // subspace type: U3Subspace
  {
    
  public:

    // default constructor
    //
    // Should never be needed.  However, compiler requires its
    // existence to dereference a map with value type Sp3RSpace, to
    // allow for possibility that the key might not be found and a
    // "default" value thus entered into the map.  And apparently it
    // *is* called, even when nominally not needed...
    inline Sp3RSpace() : Nn_max_(-999) {}

    // constructor
    Sp3RSpace(const u3::U3& sigma, int Nn_max, bool restrict_sp3r_to_u3_branching=false);
    // Constructs all U3 subspaces up to given Nn_max.

    // diagnostic output
    std::string DebugStr() const;

    // accessors
    u3::U3 sigma() const {return sigma_;}
    int Nn_max() const {return Nn_max_;}

  private:
    // space parameters
    u3::U3 sigma_;
    int Nn_max_;

  };

  std::vector<int> PartitionIrrepByNn(const sp3r::Sp3RSpace& irrep, const int Nmax);
  // Returns a list of indices for which each in Nn begins. 
}  // namespace

#endif
