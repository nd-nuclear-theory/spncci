/****************************************************************
  sp3r.h

  Sp(3,R) labeling and branching.

  Anna E. McCoy [1,2,3] and Mark A. Caprio[1]
  [1] University of Notre Dame
  [2] TRIUMF
  [3] Institute for Nuclear Theory

  SPDX-License-Identifier: MIT

  3/9/16 (aem,mac): Created based on prototype spstates.py, sp3r.py,
    and coefficients.py.
  2/1/17 (mac): Rename DebugString to DebugStr.
  7/1/17 (aem): Add modified branching rule for sp3r->u3 for A<6
  9/27/17 (aem):
    + Updated modified branching rule
    + Added upsilon_max accessor for U3Subspace giving upsilon max
      U3Subspace size still gives number of (n,rho) pairs in
      corresponding U3boson space
    + Broke off sp3r coefficients into separate module
  11/4/21 (aem): Add new functions checking if Sp(3,R)->U(3) branching
      must be restricted.
****************************************************************/

#ifndef SP3R_H_
#define SP3R_H_

#include <map>
#include <string>

#include "basis/basis.h"
#include "basis/operator.h"
#include "sp3rlib/u3.h"
#include "sp3rlib/u3boson.h"

namespace sp3r
{

  // TODO: Move into vcs?  Or separate sp3r_utils file?
  // Used in vcs.cpp but, vcs K matrix functions used in sp3r.cpp
  bool IsUnitary(const u3::U3& sigma);
  // Check if sigma is label of unitary Sp(3,R) irrep
  // based on the criteria given in jpa-18-1985-939-Rowe.

  bool ModifySp3RBranching(const u3::U3& sigma);
  // Returns true if Sp(3,R)->U(3) branching obtained by coupling
  // Sp(3,R) raising polynomials onto sigma must be modified.

  ////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////
  // Sp(3,R) irrep (space) -> U(3) irrep (subspace)
  ////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////

  // space labels: sigma (u3::U3)
  // space truncation: Nn,max (integer)
  // subspace labels: omega (u3::U3)
  // state labels within subspace: n (u3::U3), rho (integer)
  //
  // Within a space, the subspaces are ordered by:
  //   -- "canonically" increasing omega
  //
  // Within a subspace, the states are ordered by:
  //   -- "canonically" increasing n
  //      which is defined for us as lexicographical by N(lambda,mu)
  //   -- numerically increasing rho

  // container for all state labels generated in Sp(3,R) branching
  //    for use as input parameter to U3Subspace::Init()
  typedef std::multimap< u3::U3, MultiplicityTagged<u3::U3> > SpanakopitaType;
  // typedef std::pair< SpanakopitaType::iterator, SpanakopitaType::iterator > SpanakopitaRangeType;
  // typedef std::map<MultiplicityTagged<u3::U3>,MultiplicityTagged<u3::U3>::vector> RestrictedSpanakopitaType;

  class U3Subspace;
  class Sp3RSpace;

  ////////////////////////////////////////////////////////////////
  // U(3) subspace
  ////////////////////////////////////////////////////////////////

  class U3Subspace
    : public basis::BaseSubspace<
        U3Subspace,
        u3::U3,
        basis::BaseState<U3Subspace>,
        MultiplicityTagged<u3::U3>
      >
  {

  public:

    // constructor

    U3Subspace(const u3::U3& omega, int upsilon_max);
    // Construct U(3) subspace.
    //
    // This is a lightweight constructor which only stores the labels,
    // without populating the subspace with states.
    //
    // Arguments:
    //   omega (u3::U3) : labels for subspace

    // U3Subspace(
    //     const u3::U3& omega,
    //     int upsilon_max,
    //     const SpanakopitaRangeType& state_range
    //   )
    //   : U3Subspace(omega, upsilon_max)
    // {
    //   Init(state_range);
    // }

    U3Subspace(
        const u3::U3& omega,
        int upsilon_max,
        const MultiplicityTagged<u3::U3>::vector& state_set
      )
      : U3Subspace(omega, upsilon_max)
    {
      Init(state_set);
    }

    // void Init(const SpanakopitaRangeType& state_range);
    // Populate subspace
    //
    // Arguments:
    //   state_range (SpanakopitaRangeType) : begin and end
    //     iterators for states in include in subspace
    //
    // The states container contains all generated states as a
    // multimap, with key-value pairs omega -> (n,rho_max).  The
    // states are thus grouped and sorted by omega.  Only rho_max is
    // stored in the multimap, but the full rho set (1,...,rho_max)
    // will be enumerated in the subspace state listing generated by
    // this constructor.

    void Init(const MultiplicityTagged<u3::U3>::vector& state_set);
    // Alternative constructor from list of (n,rho) states

    ////////////////////////////////////////////////////////////////////////
    template<typename K1, typename K2>
    U3Subspace(
      const u3::U3& omega,
      int upsilon_max,
      const u3boson::U3Subspace& u3boson_subpace,
      K1&& K_matrix__,
      K2&& Kinv_matrix__
    )
    : BaseSubspace{{omega}},
      upsilon_max_{upsilon_max},
      K_matrix_{std::forward<K1>(K_matrix__)},
      Kinv_matrix_{std::forward<K2>(Kinv_matrix__)}
    {
      Init(u3boson_subpace);
    }

    void Init(const u3boson::U3Subspace& u3boson_subpace);

    ////////////////////////////////////////////////////////////////////////

    // accessors
    const u3::U3& U3() const
    {
      return labels();
    }

    u3::U3 omega() const { return U3(); }
    std::string LabelStr() const {return omega().Str();}



    int upsilon_max() const {return upsilon_max_;}

    // diagnostic output
    std::string DebugStr() const;

    // Currently K_matrix_ and Kinv_matrix_ only stored when
    // basis constructed using U3BosonSpace.
    inline const basis::OperatorBlock<double>& K_matrix() const
      {
        return K_matrix_;
      }
    inline const basis::OperatorBlock<double>& Kinv_matrix() const
      {
        return Kinv_matrix_;
      }

  private:
    int upsilon_max_;
    basis::OperatorBlock<double> K_matrix_, Kinv_matrix_;

  };

  ////////////////////////////////////////////////////////////////
  // Sp(3,R) space
  ////////////////////////////////////////////////////////////////

  class Sp3RSpace
    : public basis::BaseSpace<Sp3RSpace, U3Subspace>
    // subspace type: U3Subspace
  {

  public:

    // default constructor
    //
    // Should never be needed.  However, compiler requires its
    // existence to dereference a map with value type Sp3RSpace, to
    // allow for possibility that the key might not be found and a
    // "default" value thus entered into the map.  And apparently it
    // *is* called, even when nominally not needed...
    inline Sp3RSpace() : Nn_max_(-999) {}

    // constructor
    Sp3RSpace(const u3::U3& sigma, int Nn_max);

    inline Sp3RSpace(const u3::U3& sigma, int Nn_max, bool modify_sp3r_to_u3_branching)
    {
      // Whether or not branching rule must be modified is determined internally.
      // Optional bool is being deprecated.
      assert(modify_sp3r_to_u3_branching==sp3r::ModifySp3RBranching(sigma));
      Sp3RSpace(sigma,Nn_max);
    }
    // Constructs all U3 subspaces up to given Nn_max.
    // Note, restrict_sp3r_to_u3_branching = true not currently implemented.
    // Option to pass bool Deprecated in favor of ModifySp3RBranching


    Sp3RSpace(
      const u3::U3& sigma, const int Nn_max,
      const u3boson::U3BosonSpace& u3boson_space,
      const bool subspace_labels_only = false
    );

    // diagnostic output
    std::string DebugStr() const;

    // accessors
    u3::U3 sigma() const {return sigma_;}
    int Nn_max() const {return Nn_max_;}

  private:
    // space parameters
    u3::U3 sigma_;
    int Nn_max_;

  };



  // Sectors: U3Subspaces connected by operator w0
  class Sp3RSectors
    : public basis::BaseSectors<Sp3RSpace>
  {
    public:

    // Default constructor
    Sp3RSectors() = default;

    // Constructor
    Sp3RSectors(
        const Sp3RSpace& space,
        const u3::U3& omega0,
        const bool& su3_generator=false
      );

  private:
    u3::U3 omega0_;

  };


}  // namespace

#endif
