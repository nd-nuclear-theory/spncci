/****************************************************************
  explicit.cpp

  Tests of explicit SpNCCI basis construction in LSU3Shell basis.

  Required data:

    Input files are generated by

      generate_lsu3shell_relative_operators.cpp

    which is invoked through scripting in

      compute_relative_tensors_lsu3shell_rmes.py

    Example: Z=3 N=3 twice_Nsigma0=22 Nmax=2 Nstep=2 Nv=N1b=1
   
    % python3 script/compute_relative_tensors_lsu3shell_rmes.py 3 3 22 2 2 1

    Only need .rme and .dat files.

    Not saved to repository since ~3.5 Mb...

       data/lsu3shell/lsu3shell_rme_6Li_Nmax02
                                  
  Anna E. McCoy and Mark A. Caprio
  University of Notre Dame

  2/16/17 (mac): Created.  Based on compute_unit_tensor_rmes.cpp.
****************************************************************/

#include <cstdio>
#include <ctime>
#include <fstream>
#include <sys/resource.h>

#include "am/am.h"
#include "cppformat/format.h"
#include "lgi/lgi.h"
#include "lgi/lgi_solver.h"
#include "lsu3shell/lsu3shell_basis.h"
#include "lsu3shell/lsu3shell_rme.h"
#include "mcutils/eigen.h"
#include "sp3rlib/u3coef.h"
#include "sp3rlib/vcs.h" 
#include "spncci/unit_tensor.h"
#include "spncci/spncci_branching_u3s.h"
#include "spncci/spncci_branching_u3lsj.h"
#include "u3shell/relative_operator.h"
#include "u3shell/upcoupling.h"


namespace spncci
{
  void 
  ConstructSpNCCIBasisExplicit(
      const spncci::SpNCCISpace& spncci_space,
      basis::MatrixVector& lgi_expansion_matrix_vector,
      const u3shell::SpaceU3SPN& space,
      const u3shell::SectorsU3SPN& sectors,
      const u3shell::SectorsU3SPN& arel_sectors,
      basis::MatrixVector& Arel_matrices,
      std::unordered_map<u3::U3,vcs::MatrixCache, boost::hash<u3::U3>>& k_matrix_map
    )
  {}


}// end namespace

////////////////////////////////////////////////////////////////
// run parameters
////////////////////////////////////////////////////////////////

struct RunParameters
// Structure to store input parameters for run.
//
// Data members:
//   A (int): Atomic mass.
//   ...
{

  // constructor
  RunParameters(); 

  // basis parameters
  int A;
  HalfInt Nsigma_0;
  int Nsigma0_ex_max;
  int N1b;
  int Nmax;

  // filenames
  std::string lsu3shell_rme_directory;
  std::string lsu3shell_basis_filename;
  std::string Brel_filename;
  std::string Arel_filename;
  std::string Nrel_filename;
  std::string relative_unit_filename_template;

  // relative unit tensors to be studied
  //
  // Note: Should be consistant with set of tensors generated by
  // generate_lsu3shell_relative_operators.
  int T0;
  int J0;
};

RunParameters::RunParameters()
{
  // read from command line arguments
  //
  // TODO reorder filenames 
  // if (argc<8)
  //   {
  //     std::cout << "Syntax: A twice_Nsigma0 Nsigma0_ex_max N1B Nmax <basis filename> <Nrel filename> <Brel filename> <Arel filename>" 
  //               << std::endl;
  //     std::exit(1);
  //   }
  // int A = std::stoi(argv[1]); 
  // int twice_Nsigma0= std::stoi(argv[2]);
  // int Nsigma0_ex_max=std::stoi(argv[3]);
  // int N1b=std::stoi(argv[4]);
  // int Nmax = std::stoi(argv[5]);
  // std::string lsu3shell_basis_filename = argv[6];
  // std::string Nrel_filename = argv[7];
  // std::string Brel_filename = argv[8];
  // std::string Arel_filename = argv[9];
  // HalfInt Nsigma_0=HalfInt(twice_Nsigma0,2);

  // basis parameters
  A = 6;
  int twice_Nsigma0 = 22;
  Nsigma_0=HalfInt(twice_Nsigma0,2);

  Nsigma0_ex_max = 2;
  N1b = 1;
  Nmax = 2;
  lsu3shell_rme_directory = "lsu3shell_rme";
  lsu3shell_basis_filename = lsu3shell_rme_directory + "/" + "lsu3shell_basis.dat";
  Brel_filename = lsu3shell_rme_directory + "/" + "Brel_06_Nmax02.rme";
  Arel_filename = lsu3shell_rme_directory + "/" + "Arel_06_Nmax02.rme";
  Nrel_filename = lsu3shell_rme_directory + "/" + "Nrel_06_Nmax02.rme";
  relative_unit_filename_template = lsu3shell_rme_directory + "/" + "relative_unit_{:06d}.rme";

  T0=0;
  J0=-1;
}


////////////////////////////////////////////////////////////////
// main body
////////////////////////////////////////////////////////////////

int main(int argc, char **argv)
{

  ////////////////////////////////////////////////////////////////
  // initialization
  ////////////////////////////////////////////////////////////////
  
  // SU(3) caching
  u3::U3CoefInit();
  u3::UCoefCache u_coef_cache;
  u3::PhiCoefCache phi_coef_cache;
  u3::g_u_cache_enabled = true;

  // global numerical parameter
  //
  // Apparently referenced via cut-and-paste extern declarations (UGLY).
  double zero_threshold=1e-6;

  // run parameters
  RunParameters run_parameters;

  // Eigen OpenMP multithreading mode
  Eigen::initParallel();
  Eigen::setNbThreads(0);  // disable Eigen internal multithreading

  ////////////////////////////////////////////////////////////////
  // read lsu3shell basis and operators
  ////////////////////////////////////////////////////////////////

  std::cout << "Read lsu3shell inputs..." << std::endl;

  // read lsu3shell basis (regroup into U3SPN subspaces)
  lsu3shell::LSU3BasisTable lsu3shell_basis_table;
  lsu3shell::U3SPNBasisLSU3Labels lsu3shell_basis_provenance;
  u3shell::SpaceU3SPN lsu3shell_space;
  lsu3shell::ReadLSU3Basis(
      run_parameters.Nsigma_0,run_parameters.lsu3shell_basis_filename,
      lsu3shell_basis_table,lsu3shell_basis_provenance,lsu3shell_space
    );

  // read Brel
  u3shell::OperatorLabelsU3ST Brel_labels(-2,u3::SU3(0,2),0,0,0);
  u3shell::SectorsU3SPN Brel_sectors(lsu3shell_space,Brel_labels,true);
  basis::MatrixVector Brel_matrices;
  lsu3shell::ReadLSU3ShellRMEs(
      run_parameters.Brel_filename,
      lsu3shell_basis_table,lsu3shell_space,
      Brel_labels,Brel_sectors,Brel_matrices
    );

  // read Arel
  u3shell::OperatorLabelsU3ST Arel_labels(2,u3::SU3(2,0),0,0,0);
  u3shell::SectorsU3SPN Arel_sectors(lsu3shell_space,Arel_labels,true);
  basis::MatrixVector Arel_matrices;
  lsu3shell::ReadLSU3ShellRMEs(
      run_parameters.Arel_filename,
      lsu3shell_basis_table,lsu3shell_space,
      Arel_labels,Arel_sectors,Arel_matrices
    );

  // read Nrel
  u3shell::OperatorLabelsU3ST Nrel_labels(0,u3::SU3(0,0),0,0,0);
  u3shell::SectorsU3SPN Nrel_sectors(lsu3shell_space,Nrel_labels,true);
  basis::MatrixVector Nrel_matrices;
  lsu3shell::ReadLSU3ShellRMEs(
      run_parameters.Nrel_filename,
      lsu3shell_basis_table,lsu3shell_space,
      Nrel_labels,Nrel_sectors,Nrel_matrices
    );

  // read Nrel as Ncm
  u3shell::OperatorLabelsU3ST Ncm_labels(0,u3::SU3(0,0),0,0,0);
  u3shell::SectorsU3SPN Ncm_sectors(lsu3shell_space,Ncm_labels,true);
  basis::MatrixVector Ncm_matrices;
  lsu3shell::GenerateLSU3ShellNcmRMEs(
      run_parameters.A,
      run_parameters.Nrel_filename,
      lsu3shell_basis_table,lsu3shell_space,
      Ncm_matrices
    );

  ////////////////////////////////////////////////////////////////
  // solve for LGIs
  ////////////////////////////////////////////////////////////////

  std::cout << "Solve for LGIs..." << std::endl;

  lgi::MultiplicityTaggedLGIVector lgi_families;
  basis::MatrixVector lgi_expansions;
  lgi::GenerateLGIExpansion(
      lsu3shell_space, 
      Brel_sectors,Brel_matrices,Ncm_sectors,Ncm_matrices,
      run_parameters.Nsigma_0,
      lgi_families,lgi_expansions
    );

  // diagnostics
  std::cout << fmt::format("  LGI families {}",lgi_families.size()) << std::endl;
  lgi::WriteLGILabels(lgi_families,std::cout);

  ////////////////////////////////////////////////////////////////
  // set up SpNCCI space
  ////////////////////////////////////////////////////////////////

  std::cout << "Set up SpNCCI space..." << std::endl;

  spncci::SpNCCISpace spncci_space;
  spncci::SigmaIrrepMap sigma_irrep_map;  // persistent container to store branchings
  spncci::NmaxTruncator truncator(run_parameters.Nsigma_0,run_parameters.Nmax);
  spncci::GenerateSpNCCISpace(lgi_families,truncator,spncci_space,sigma_irrep_map);

  // diagnostics
  std::cout << fmt::format("  Irrep families {}",spncci_space.size()) << std::endl;
  std::cout << fmt::format("  TotalU3Subspaces {}",spncci::TotalU3Subspaces(spncci_space)) << std::endl;
  std::cout << fmt::format("  TotalDimensionU3 {}",spncci::TotalDimensionU3S(spncci_space)) << std::endl;

  ////////////////////////////////////////////////////////////////
  // do explicit subspace constructions
  ////////////////////////////////////////////////////////////////


}
