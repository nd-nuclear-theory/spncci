/****************************************************************
  explicit.cpp

  Tests of explicit SpNCCI basis construction in LSU3Shell basis.

  Required data:

    Input files are generated by

      generate_lsu3shell_relative_operators.cpp

    which is invoked through scripting in

      compute_relative_tensors_lsu3shell_rmes.py

    Example: Z=3 N=3 twice_Nsigma0=22 Nmax=2 Nstep=2 Nv=N1b=1
   
    % python3 script/compute_relative_tensors_lsu3shell_rmes.py 3 3 22 2 2 1

    Only need .rme and .dat files.

    Not saved to repository since ~3.5 Mb...

       data/lsu3shell/lsu3shell_rme_6Li_Nmax02
                                  
  Anna E. McCoy and Mark A. Caprio
  University of Notre Dame

  2/16/17 (mac): Created.  Based on compute_unit_tensor_rmes.cpp.
****************************************************************/

#include <cstdio>
#include <ctime>
#include <fstream>
#include <sys/resource.h>

#include "cppformat/format.h"
#include "lgi/lgi_solver.h"
#include "spncci/computation_control.h"
#include "spncci/explicit_construction.h"
#include "spncci/io_control.h"

// to vett as moved into computation_control 
#include "mcutils/eigen.h"
#include "spncci/branching_u3s.h"
#include "spncci/branching_u3lsj.h"
#include "u3shell/upcoupling.h"

////////////////////////////////////////////////////////////////
// WIP code
//
// to extract to spncci library when ready
////////////////////////////////////////////////////////////////

namespace spncci
{


  void
  RecurseUnitTensors(
      spncci::UnitTensorMatricesByIrrepFamily unit_tensor_matrices
    )
  // Recursively populate sectors for unit tensors.
  //
  // Recursing unit tensors implies unit tensors are already cursed.
  //
  // Messy testbed code taken more or less verbatim from
  // compute_unit_tensor_rmes.cpp.  Has lots of timing stuff, etc., in
  // it, to simulate parallel runs from SDSU visit, including private
  // SU(3) coefficient caches...
  {
#if 0
    //  if(Nmax!=0)
    {
      std::map<int,double> timing_map;
      std::map<int,std::vector<std::pair<int,int>>> lgi_distribution;
      std::map<int,std::vector<int>>  sector_count_map;
      std::map<int,std::vector<double>> individual_times;
      std::map<int,u3::UCoefCache> u_cache_map;
      std::pair<int,int> Nn_pair(0,0);
      int num_nodes=1;
      int counter=0; 
      for(int n=0; n<num_nodes; ++n)
        timing_map[n]=0;

      for(auto it=unit_tensor_matrices.begin(); it!=unit_tensor_matrices.end(); ++it)
        {
          clock_t start_time=std::clock();

          //REMOVE
          // if(it->first.first!=33 || it->first.second!=3)
          //   continue;
          //

          int node=counter%num_nodes;
          assert(node<num_nodes);
          //Timing data
          spncci::GenerateUnitTensorMatrix(
              N1b,Nmax,it->first,sp_irrep_vector,u_cache_map[node], phi_coef_cache,k_matrix_map,
              unit_tensor_labels,unit_tensor_matrices);

          double duration=(std::clock()-start_time)/(double) CLOCKS_PER_SEC;
          int num_sector=unit_tensor_matrices[it->first][Nn_pair].size();

          timing_map[node]+=duration;
          individual_times[node].push_back(duration);
          lgi_distribution[node].push_back(it->first);
          sector_count_map[node].push_back(num_sector);
          counter++;

        }
      // std::cout<<"individual pairs"<<std::endl;
      // for(int n=0; n<num_nodes; ++n)
      //   {
      //     std::cout<<"node"<<n<<std::endl;
      //     int i_stop=lgi_distribution[n].size();
      //     for(int i=0; i<i_stop; ++i)
      //       {
      //         std::cout<<lgi_distribution[n][i].first<<" "<<lgi_distribution[n][i].second<<"  "
      //         <<sector_count_map[n][i]<<"  "<<individual_times[n][i]<<std::endl;
      //       }
      //     std::cout<<"  "<<std::endl;

      //   }

      // std::cout<<"summarizing"<<std::endl;
      // for(int n=0; n<num_nodes; ++n)
      //   {
      //     std::cout<<"node "<<n<<std::endl;
      //     std::cout<<" time "<<timing_map[n]<<std::endl;
      //     std::cout<<" U cache size "<<u_cache_map[n].size()<<std::endl;
      //   } 
    }
#endif
  }



}// end namespace

////////////////////////////////////////////////////////////////
// explicit construction checks
////////////////////////////////////////////////////////////////

void 
CheckOrthonormalityExplicit(
    const spncci::BabySpNCCISpace& baby_spncci_space,
    const basis::MatrixVector& spncci_expansions
  )
// Check orthonormality of SpNCCI basis vectors from explicit
// expansion in lsu3shell basis.
//
// Takes pairs of BabySpNCCI subspaces sharing the same U3SPN, and
// thus the same underlying lsu3shell subspace.
//
// Arguments:
//   ...
{

  for (int bra_subspace_index=0; bra_subspace_index<baby_spncci_space.size(); ++bra_subspace_index)
    for (int ket_subspace_index=bra_subspace_index; ket_subspace_index<baby_spncci_space.size(); ++ket_subspace_index)
      {
        // extract subspace info
        const spncci::BabySpNCCISubspace& bra_subspace = baby_spncci_space.GetSubspace(bra_subspace_index);
        const spncci::BabySpNCCISubspace& ket_subspace = baby_spncci_space.GetSubspace(ket_subspace_index);

        // short circuit if subspaces have different underlying lsu3shell subspaces
        if (not (bra_subspace.omegaSPN()==ket_subspace.omegaSPN()))
          continue;

        // calculate overlaps
        Eigen::MatrixXd overlap_matrix = spncci_expansions[bra_subspace_index].transpose()*spncci_expansions[ket_subspace_index];
        Eigen::MatrixXd overlap_matrix_minus_identity = overlap_matrix - Eigen::MatrixXd::Identity(overlap_matrix.rows(),overlap_matrix.cols());
        mcutils::ChopMatrix(overlap_matrix);
        mcutils::ChopMatrix(overlap_matrix_minus_identity);

        // check overlaps
        bool on_diagonal = (bra_subspace_index==ket_subspace_index);
        bool success = on_diagonal ? mcutils::IsZero(overlap_matrix_minus_identity)
          : mcutils::IsZero(overlap_matrix);
        
        std::cout
          << fmt::format(
              "  bra index {} labels {} ket index {} labels {}",
              bra_subspace_index,bra_subspace.LabelStr(),
              ket_subspace_index,ket_subspace.LabelStr()
            )
          << std::endl;
        std::cout << fmt::format("  on_diagonal {}",on_diagonal)
                  << std::endl;
        std::cout << fmt::format("  {}",success ? "PASS" : "FAIL")
                  << std::endl;
        std::cout << mcutils::FormatMatrix(overlap_matrix,"8.5f","  ") << std::endl;
        std::cout << std::endl;
      }
}

////////////////////////////////////////////////////////////////
// run parameters
////////////////////////////////////////////////////////////////

struct RunParameters
// Structure to store input parameters for run.
//
// Data members:
//   A (int): Atomic mass.
//   ...
{

  // constructor
  RunParameters(); 

  // basis parameters
  int A;
  HalfInt Nsigma_0;
  int Nsigma0_ex_max;
  int N1b;
  int Nmax;

  // filenames
  std::string lsu3shell_rme_directory;
  std::string lsu3shell_basis_filename;
  std::string Brel_filename;
  std::string Arel_filename;
  std::string Nrel_filename;
  std::string relative_unit_tensor_filename_template;
};

RunParameters::RunParameters()
{
  // read from command line arguments
  //
  // TODO reorder filenames 
  // if (argc<8)
  //   {
  //     std::cout << "Syntax: A twice_Nsigma0 Nsigma0_ex_max N1B Nmax <basis filename> <Nrel filename> <Brel filename> <Arel filename>" 
  //               << std::endl;
  //     std::exit(1);
  //   }
  // int A = std::stoi(argv[1]); 
  // int twice_Nsigma0= std::stoi(argv[2]);
  // int Nsigma0_ex_max=std::stoi(argv[3]);
  // int N1b=std::stoi(argv[4]);
  // int Nmax = std::stoi(argv[5]);
  // std::string lsu3shell_basis_filename = argv[6];
  // std::string Nrel_filename = argv[7];
  // std::string Brel_filename = argv[8];
  // std::string Arel_filename = argv[9];
  // HalfInt Nsigma_0=HalfInt(twice_Nsigma0,2);

  // basis parameters
  A = 6;
  int twice_Nsigma0 = 22;
  Nsigma_0=HalfInt(twice_Nsigma0,2);

  Nsigma0_ex_max = 2;
  N1b = 1;
  Nmax = 2;
  lsu3shell_rme_directory = "lsu3shell_rme";
  lsu3shell_basis_filename = lsu3shell_rme_directory + "/" + "lsu3shell_basis.dat";
  Brel_filename = lsu3shell_rme_directory + "/" + "Brel_06_Nmax02.rme";
  Arel_filename = lsu3shell_rme_directory + "/" + "Arel_06_Nmax02.rme";
  Nrel_filename = lsu3shell_rme_directory + "/" + "Nrel_06_Nmax02.rme";
  relative_unit_tensor_filename_template = lsu3shell_rme_directory + "/" + "relative_unit_{:06d}.rme";
}


////////////////////////////////////////////////////////////////
// main body
////////////////////////////////////////////////////////////////

int main(int argc, char **argv)
{

  ////////////////////////////////////////////////////////////////
  // initialization
  ////////////////////////////////////////////////////////////////
  
  // SU(3) caching
  u3::U3CoefInit();
  u3::UCoefCache u_coef_cache;
  u3::PhiCoefCache phi_coef_cache;
  u3::g_u_cache_enabled = true;

  // numerical parameter for certain calculations
  double zero_threshold=1e-6;

  // run parameters
  RunParameters run_parameters;

  // Eigen OpenMP multithreading mode
  Eigen::initParallel();
  Eigen::setNbThreads(0);  // disable Eigen internal multithreading

  ////////////////////////////////////////////////////////////////
  // read lsu3shell basis
  ////////////////////////////////////////////////////////////////

  std::cout << "Read lsu3shell basis..." << std::endl;

  // read lsu3shell basis (regroup into U3SPN subspaces)
  lsu3shell::LSU3BasisTable lsu3shell_basis_table;
  lsu3shell::U3SPNBasisLSU3Labels lsu3shell_basis_provenance;
  u3shell::SpaceU3SPN lsu3shell_space;
  lsu3shell::ReadLSU3Basis(
      run_parameters.Nsigma_0,run_parameters.lsu3shell_basis_filename,
      lsu3shell_basis_table,lsu3shell_basis_provenance,lsu3shell_space
    );

  ////////////////////////////////////////////////////////////////
  // solve for LGIs
  ////////////////////////////////////////////////////////////////

  std::cout << "Solve for LGIs..." << std::endl;


    // diagnostics
    // std::cout << "Arel operator..." << std::endl;
    // std::cout << "Arel sectors" << std::endl;
    // std::cout << Arel_sectors.DebugStr();
    // std::cout << "Arel matrices" << std::endl;
    // for (int sector_index=0; sector_index<Arel_sectors.size(); ++sector_index)
    //   {
    //     std::cout << fmt::format("  sector {}",sector_index) << std::endl;
    //     std::cout << mcutils::FormatMatrix(Arel_matrices[sector_index],"8.5f","  ") << std::endl;
    //   }


  u3shell::SectorsU3SPN Brel_sectors, Arel_sectors, Nrel_sectors;
  basis::MatrixVector Brel_matrices, Arel_matrices, Nrel_matrices;
  spncci::ReadLSU3ShellSymplecticOperatorRMEs(
      lsu3shell_basis_table,lsu3shell_space, 
      run_parameters.Brel_filename,Brel_sectors,Brel_matrices,
      run_parameters.Arel_filename,Arel_sectors,Arel_matrices,
      run_parameters.Nrel_filename,Nrel_sectors,Nrel_matrices
    );

  const u3shell::SectorsU3SPN& Ncm_sectors = Nrel_sectors;
  basis::MatrixVector Ncm_matrices;
  lsu3shell::GenerateLSU3ShellNcmRMEs(
      lsu3shell_space,Nrel_sectors,Nrel_matrices,
      run_parameters.A,
      Ncm_matrices
    );


  lgi::MultiplicityTaggedLGIVector lgi_families;
  basis::MatrixVector lgi_expansions;
  lgi::GenerateLGIExpansion(
      lsu3shell_space, 
      Brel_sectors,Brel_matrices,Ncm_sectors,Ncm_matrices,
      run_parameters.Nsigma_0,
      lgi_families,lgi_expansions
    );

  // diagnostics
  std::cout << fmt::format("  LGI families {}",lgi_families.size()) << std::endl;
  lgi::WriteLGILabels(lgi_families,std::cout);

  ////////////////////////////////////////////////////////////////
  // set up SpNCCI space
  ////////////////////////////////////////////////////////////////

  std::cout << "Set up SpNCCI space..." << std::endl;

  // build SpNCCI irrep branchings
  spncci::SpNCCISpace spncci_space;
  spncci::SigmaIrrepMap sigma_irrep_map;  // persistent container to store branchings
  spncci::NmaxTruncator truncator(run_parameters.Nsigma_0,run_parameters.Nmax);
  spncci::GenerateSpNCCISpace(lgi_families,truncator,spncci_space,sigma_irrep_map);

  // put SpNCCI space into standard linearized container
  spncci::BabySpNCCISpace baby_spncci_space(spncci_space);

  // diagnostics
  std::cout << fmt::format("  Irrep families {}",spncci_space.size()) << std::endl;
  std::cout << fmt::format("  TotalU3Subspaces {}",spncci::TotalU3Subspaces(spncci_space)) << std::endl;
  std::cout << fmt::format("  TotalDimensionU3 {}",spncci::TotalDimensionU3S(spncci_space)) << std::endl;


  ////////////////////////////////////////////////////////////////
  // precompute K matrices
  ////////////////////////////////////////////////////////////////

  std::cout << "Precompute K matrices..." << std::endl;

  // traverse distinct sigma values in SpNCCI space, generating K
  // matrices for each
  spncci::KMatrixCache k_matrix_cache;
  spncci::PrecomputeKMatrices(sigma_irrep_map,k_matrix_cache);

  ////////////////////////////////////////////////////////////////
  // do explicit subspace constructions
  ////////////////////////////////////////////////////////////////

  std::cout << "Explicitly construct SpNCCI basis states using Arel..." << std::endl;
  basis::MatrixVector spncci_expansions;
  spncci::ConstructSpNCCIBasisExplicit(
      lsu3shell_space,lgi_expansions,baby_spncci_space,k_matrix_cache,
      Arel_sectors,Arel_matrices,spncci_expansions
    );

  std::cout << "Check orthonormality for all SpNCCI subspaces sharing same underlying lsu3shell subspace..." << std::endl;
  CheckOrthonormalityExplicit(baby_spncci_space,spncci_expansions);

  ////////////////////////////////////////////////////////////////
  // read lsu3shell seed unit tensor rmes
  ////////////////////////////////////////////////////////////////

  std::cout << "Read seed unit tensor rmes..." << std::endl;

  // storage for seed unit tensor rmes
  //
  //   lgi_unit_tensor_labels: vector of labels for seed unit tensors
  //   lgi_unit_tensor_lsu3shell_sectors: vector of lsu3shell sectors for seed unit tensors
  //   lgi_unit_tensor_matrices: vector of matrices for these sectors
  std::vector<u3shell::RelativeUnitTensorLabelsU3ST> lgi_unit_tensor_labels;
  std::vector<u3shell::SectorsU3SPN> lgi_unit_tensor_sectors;
  std::vector<basis::MatrixVector> lgi_unit_tensor_lsu3shell_matrices;

  // determine set of seed unit tensors
  //
  // i.e., those for which we calculate seed rmes among the LGIs
  //
  // Note: Should be consistant with set of tensors generated by
  // generate_lsu3shell_relative_operators.
  int Nmax_for_unit_tensors = run_parameters.Nsigma0_ex_max+2*run_parameters.N1b;  // max quanta for pair in LGI (?)
  int J0 = -1;  // all J0
  int T0 = 0;
  const bool restrict_positive_N0 = false;  // don't restrict to N0 positive
  u3shell::GenerateRelativeUnitTensorLabelsU3ST(
      Nmax_for_unit_tensors, lgi_unit_tensor_labels,
      J0,T0,restrict_positive_N0
    );

  // diagnostic
  std::cout << fmt::format("  seed unit tensors {}",lgi_unit_tensor_labels.size()) << std::endl;

  spncci::ReadLSU3ShellSeedUnitTensorRMEs(
      lsu3shell_basis_table,lsu3shell_space,
      lgi_unit_tensor_labels,
      run_parameters.relative_unit_tensor_filename_template,
      lgi_unit_tensor_sectors,
      lgi_unit_tensor_lsu3shell_matrices
    );

  ////////////////////////////////////////////////////////////////
  // transform and store seed rmes for use in SpNCCI recurrence
  ////////////////////////////////////////////////////////////////

  std::cout << "Transform and store seed unit tensor rmes..." << std::endl;

  // transform to SpNCCI LGI RMEs
  std::vector<basis::MatrixVector> lgi_unit_tensor_spncci_matrices;
  spncci::TransformSeedUnitTensorRMEs(
      lgi_expansions,
      lgi_unit_tensor_labels,
      lgi_unit_tensor_sectors,
      lgi_unit_tensor_lsu3shell_matrices,
      lgi_unit_tensor_spncci_matrices
    );

  // store unit tensor matrix elements for recurrence
  spncci::UnitTensorMatricesByIrrepFamily unit_tensor_matrices;
  spncci::StoreSeedUnitTensorRMEs(
      lgi_unit_tensor_labels,
      lgi_unit_tensor_sectors,
      lgi_unit_tensor_spncci_matrices,
      unit_tensor_matrices,
      zero_threshold
    );

  ////////////////////////////////////////////////////////////////
  // ladder unit tensor rmes to full SpNCCI basis
  ////////////////////////////////////////////////////////////////

  // TODO
}
