/****************************************************************
  spncci.cpp

  Tests of explicit SpNCCI basis construction in LSU3Shell basis.

  This code just tests normalization, but using clean refactored
  infrastructure.  Other deeper tests (of unit tensor matrix elements)
  were carried out in compute_unit_tensor_rmes.cpp.

  Required data:

  * Relative operator lsu3shell rme input files are generated by

      generate_lsu3shell_relative_operators.cpp

    which is invoked through scripting in

      compute_relative_tensors_lsu3shell_rmes.py

    Example: Z=3 N=3 twice_Nsigma0=22 Nmax=2 Nstep=2 N1v[=N1b]=1

    % python3 script/compute_relative_tensors_lsu3shell_rmes.py 3 3 22 2 2 1

    Only need .rme and .dat files.

    Not saved to repository since ~3.5 Mb...

       data/lsu3shell/lsu3shell_rme_6Li_Nmax02

       * Relative Hamiltonian (and observable) upcoupled rme files are
    generated by

      generate_relative_u3st_operators

    which is invoked manually for now as

      generate_relative_u3st_operators A Nmax N1v basename

   Example:

       ../operators/generate_relative_u3st_operators 6 2 1 hamiltonian

       with hamiltonian.load containing

       20    // hw
       Tintr 1.0    // coef
       INT 1.0 4 0 0 0 relative_observables/JISP16_Nmax20_hw20.0_rel.dat // coef Jmax J0 T0 g0 interaction_filename

       ../operators/generate_relative_u3st_operators 6 2 1 Nintr

       with Nintr.load containing

       20    // hw
       Nintr 1.0    // coef

       ../operators/generate_relative_u3st_operators 6 2 1 r2intr

       with r2intr.load containing

       20    // hw
       r2intr 1.0    // coef

   % ln -s ../../data/relative_observables/




  Anna E. McCoy and Mark A. Caprio
  University of Notre Dame

  2/20/17 (mac): Created (starting from explicit.cpp).
  4/9/17 (aem): Incorporated baby spncci hypersectors
  6/5/17 (mac): Read relative rather than intrinsic symplectic operators.
  6/16/17 (aem) : offload to computation and io control
  10/4/17 (aem) : Fixed basis construction and recurrence for A<6
  1/16/18 (aem) : Offloaded explicit construction and recurrence
    checks to explicit_construction.h
  1/30/18 (aem): Overhalled seed generation and recurrence
  2/5/18 (aem): Switched from using u3s sectors to u3s hypersectors
    combined with observable spaces
  2/15/18 (aem) : Removed gamma_max=0 lgi
    + Cleaned up codes and factored spncci.cpp into simpler functions
  5/2/19 (aem) : Moved ComputeManyBodyRMEs into hyperblocks_u3s


Notes:
branching2 currently used for branching.  branching has old definitions still temp used for 
basis statistics
****************************************************************/

#include <cstdio>
#include <ctime>
#include <fstream>
#include <istream>
#include <iostream>
#include <sys/resource.h>
#include <omp.h>

#include "Spectra/SymEigsSolver.h"  // from spectra
#include "am/halfint.h"
#include "am/halfint_fmt.h"
#include "fmt/format.h"
#include "mcutils/parsing.h"
#include "mcutils/io.h"
#include "spncci/recurrence.h"
#include "lgi/lgi_unit_tensors.h"
#include "mcutils/profiling.h"
#include "mcutils/eigen.h"
#include "spncci/computation_control.h"
#include "spncci/decomposition.h"
#include "spncci/eigenproblem.h"
#include "spncci/explicit_construction.h"
#include "spncci/io_control.h"
#include "spncci/computation_control.h"
#include "spncci/results_output.h"
#include "spncci/transform_basis.h"
#include "spncci/vcs_cache.h"
#include "spncci/hyperblocks_u3s.h"
////////////////////////////////////////////////////////////////
// WIP code
//
// to extract to spncci library when ready
////////////////////////////////////////////////////////////////
namespace spncci
{
//////////////////////////////////////////

  void GetVarianceBlock(
    const spncci::BabySpNCCISpace& baby_spncci_space,
    const u3shell::ObservableSpaceU3S& observable_space,
    const HalfInt& J0,
    const spncci::SpaceSpBasis& spbasis_bra, //For a given J
    const spncci::SpaceSpBasis& spbasis_ket, //For a given J
    const std::vector<spncci::LGIPair>& lgi_pairs, //Defines tiles to get computed 
    int observable_index, int hw_index,
    spncci::OperatorBlock& operator_matrix
  )
  //
  {
    // Get dimension of basis 
    int basis_size_bra=spbasis_bra.FullDimension();
    int basis_size_ket=spbasis_ket.FullDimension();
    HalfInt Jp=spbasis_bra.J();
    HalfInt J=spbasis_ket.J();

    std::vector<std::vector<int>> offsets_bra;
    std::vector<std::vector<int>> offsets_ket;
    spncci::GetSpBasisOffsets(spbasis_bra,offsets_bra);
    spncci::GetSpBasisOffsets(spbasis_ket,offsets_ket);

    //Set up full matrix 
    operator_matrix=spncci::OperatorBlock::Zero(basis_size_bra,basis_size_ket);

    //Private Caches
    u3::WCoefCache w_cache;
    // std::cout<<"entering variances for loop"<<std::endl;
    #pragma omp parallel for schedule(dynamic) private(w_cache)
    for(int i=0; i<lgi_pairs.size(); ++i)
      { 
        const spncci::LGIPair& lgi_pair=lgi_pairs[i];
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        // Generate irrep pair tile
        ///////////////////////////////////////////////////////////////////////////////////////////////////
        int irrep_family_index_bra, irrep_family_index_ket;
        std::tie(irrep_family_index_bra,irrep_family_index_ket)=lgi_pair;
        const int spbasis_index_bra=spbasis_bra.LookUpSubspaceIndex(irrep_family_index_bra);
        const int spbasis_index_ket=spbasis_ket.LookUpSubspaceIndex(irrep_family_index_ket);
    
        const spncci::SubspaceSpBasis& spbasis_subspace_bra=spbasis_bra.GetSubspace(spbasis_index_bra);
        const spncci::SubspaceSpBasis& spbasis_subspace_ket=spbasis_ket.GetSubspace(spbasis_index_ket);
    
        const std::vector<int>& offsets_bra_subspace=offsets_bra[spbasis_index_bra];
        const std::vector<int>& offsets_ket_subspace=offsets_ket[spbasis_index_ket];
    
        const int tile_dimension_bra=spbasis_subspace_bra.dimension();
        const int tile_dimension_ket=spbasis_subspace_ket.dimension();
        
        // std::cout<<"tile dimensions "<<tile_dimension_bra<<"  "<<tile_dimension_ket<<std::endl;

        if(tile_dimension_ket==0 || tile_dimension_bra==0)
          continue;

        const int start_index_bra=offsets_bra_subspace[0];
        const int start_index_ket=offsets_ket_subspace[0];
        /////////////////////////////////////////////////////////////////////////////////////////////////
        //// Get tiles an accumulate in operator_matrix
        /////////////////////////////////////////////////////////////////////////////////////////////////
        bool get_adjoint=irrep_family_index_bra<irrep_family_index_ket;
        // std::cout<<"irrep pair "<<irrep_family_index_bra<<"  "<<irrep_family_index_ket<<"  "<<get_adjoint<<std::endl;
        if(get_adjoint)
          {
            // std::cout<<"adjoint tile "<<std::endl;
            spncci::LGIPair lgi_pair_adjoint(irrep_family_index_ket,irrep_family_index_bra);
            std::vector<spncci::ObservableHypersectorLabels> list_baby_spncci_hypersectors;
            basis::OperatorHyperblocks<double> baby_spncci_observable_hyperblocks;


            spncci::GetBabySpNCCIHyperBlocks(
              observable_index,hw_index,lgi_pair_adjoint,
              list_baby_spncci_hypersectors,
              baby_spncci_observable_hyperblocks
              );

            spncci::OperatorBlock adjoint_tile;
            spncci::GetOperatorTile(
              baby_spncci_space,observable_space,
              spbasis_subspace_ket,spbasis_subspace_bra,
              offsets_ket_subspace,offsets_bra_subspace,
              J0,J,Jp,hw_index,observable_index,
              lgi_pair_adjoint,w_cache,
              list_baby_spncci_hypersectors,
              baby_spncci_observable_hyperblocks,
              adjoint_tile
            );
            

            // std::cout<<adjoint_tile<<std::endl;
            // std::cout<<"dimensions "<<start_index_ket<<"  "<<start_index_bra<<"  "<<tile_dimension_ket<<"  "<<tile_dimension_bra<<std::endl;
            // std::cout<<adjoint_tile.rows()<<"  "<<adjoint_tile.cols()<<std::endl;
            operator_matrix.block(start_index_bra,start_index_ket,tile_dimension_bra,tile_dimension_ket)
              =adjoint_tile.transpose();
          }
        else
          {
            // std::cout<<"tile"<<std::endl;

            std::vector<spncci::ObservableHypersectorLabels> list_baby_spncci_hypersectors;
            basis::OperatorHyperblocks<double> baby_spncci_observable_hyperblocks;
            spncci::GetBabySpNCCIHyperBlocks(
              observable_index,hw_index,lgi_pair,
              list_baby_spncci_hypersectors,
              baby_spncci_observable_hyperblocks
              );

            // std::cout<<"get operator tile "<<std::endl;
            spncci::OperatorBlock tile;
            spncci::GetOperatorTile(
              baby_spncci_space,observable_space,spbasis_subspace_bra,spbasis_subspace_ket,
              offsets_bra_subspace,offsets_ket_subspace,J0,Jp,J,hw_index,observable_index,
              lgi_pair,w_cache,list_baby_spncci_hypersectors,baby_spncci_observable_hyperblocks,
              tile
            );
            
            // std::cout<<tile<<std::endl;

            operator_matrix.block(start_index_bra,start_index_ket,tile_dimension_bra,tile_dimension_ket)=tile;
          }
      } //lgi_pair
  }

void CalculateVariance(
  const spncci::OperatorBlock& eigenvectors,
  const spncci::OperatorBlock& operator_matrix,
  spncci::OperatorBlock& variance_block
  )
  {
    variance_block=eigenvectors.transpose()*operator_matrix*operator_matrix.transpose()*eigenvectors;
  }

void GetVariances(
    const spncci::BabySpNCCISpace& baby_spncci_space,
    const u3shell::ObservableSpaceU3S& observable_space,
    int observable_index, int hw_index, const HalfInt& J0,
    const std::vector<std::pair<int,int>>& sectors_J,
    spncci::RunParameters& run_parameters,
    std::set<int>& irrep_families_H,
    std::vector<std::set<int>>& list_irrep_families_V,
    std::vector<std::vector<std::vector<double>>>& variances
  )
 // TODO: generalize to take list of observables 
  {
    const std::vector<HalfInt>& Jvalues=run_parameters.J_values;
    // std::cout<<"Set up J branched basis for H space"<<std::endl;
    std::vector<spncci::SpaceSpBasis> spbasis_H_byJ(Jvalues.size());
    for(int j=0; j<Jvalues.size(); ++j)
      spbasis_H_byJ[j]=SpaceSpBasis(baby_spncci_space, Jvalues[j], irrep_families_H);

    // std::cout<<"create list of lgi pairs"<<std::endl;
    std::vector<spncci::LGIPair>lgi_pairs_H;
    for(int irrep_family_index_bra : irrep_families_H)
      for(int irrep_family_index_ket : irrep_families_H)
        {
          if (irrep_family_index_bra>=irrep_family_index_ket)
            lgi_pairs_H.emplace_back(irrep_family_index_bra,irrep_family_index_ket);
        }
    
    // observable_index and J0 for Hamiltonian are both zero
    int observable_index_H=0;
    HalfInt J0_H=0;

    // std::cout<<"Set up eigenvector and eigenvalue containers"<<std::endl;
    std::vector<spncci::Vector> eigenvalues(Jvalues.size());  // eigenvalues by J subspace
    std::vector<spncci::Matrix> eigenvectors(Jvalues.size());  // eigenvectors by J subspace
    
    // std::cout<<"For each J, construct Hamiltonian and get eigensystem"<<std::endl;
    for(int j=0; j<Jvalues.size(); ++j)
      {
        const HalfInt& J=Jvalues[j]; 
        // set up eigensystem containers
        spncci::Vector& eigenvalues_J = eigenvalues[j];
        spncci::Matrix& eigenvectors_J = eigenvectors[j];   
        
        // Get truncated basis branched to J
        const spncci::SpaceSpBasis& spbasis_H=spbasis_H_byJ[j];
        
        // std::cout<<"construct Hamiltonian"<<std::endl;
        spncci::OperatorBlock hamiltonian_matrix;
        spncci::ConstructSymmetricOperatorMatrix(
            baby_spncci_space,observable_space,
            J0_H,spbasis_H,spbasis_H,lgi_pairs_H,
            observable_index_H, hw_index,
            hamiltonian_matrix
          );

        // std::cout<<"Solve Hamiltonian"<<std::endl;
        spncci::SolveHamiltonian(
            hamiltonian_matrix,
            run_parameters.num_eigenvalues,
            run_parameters.eigensolver_num_convergence,
            run_parameters.eigensolver_max_iterations,
            run_parameters.eigensolver_tolerance,
            eigenvalues_J,eigenvectors_J
          );
      }//end j


    // std::cout<<"Initializing variances container"<<std::endl;
    variances.resize(list_irrep_families_V.size());
    for(int i=0; i<list_irrep_families_V.size(); ++i)
      variances[i].resize(Jvalues.size());

    // std::cout<<"Iterate over different sets of irrep familiy indices defining difference variance subspaces"<<std::endl;
    for(int i=0; i<list_irrep_families_V.size(); ++i)
      {
        // std::cout<<"iteration "<<i<<std::endl;
        const std::set<int>& irrep_families_V=list_irrep_families_V[i];
        //create list of lgi pairs 
        std::vector<spncci::LGIPair>lgi_pairs_HV;
        for(int irrep_family_index_bra : irrep_families_H)
          for(int irrep_family_index_ket : irrep_families_V)
            {
              // std::cout<<"irrep pairs "<<irrep_family_index_bra<<"  "<<irrep_family_index_ket<<std::endl;
              lgi_pairs_HV.emplace_back(irrep_family_index_bra,irrep_family_index_ket);
            }
        
        // std::cout<<"Iterate over J sectors of operator"<<std::endl;
        for(const std::pair<int,int>& J_pair : sectors_J)
          {

            int jp,j; 
            std::tie(jp,j)=J_pair;
            const HalfInt& Jp=Jvalues[jp];
            const HalfInt& J=Jvalues[j];

            // std::cout<<"get J branched basis for H and V space"<<std::endl<<Jp<<"  "<<J<<std::endl;
            const spncci::SpaceSpBasis& spbasis_H=spbasis_H_byJ[jp];
            spncci::SpaceSpBasis spbasis_V=SpaceSpBasis(baby_spncci_space, J, irrep_families_V);
            
            std::cout<<spbasis_V.DebugStr()<<std::endl;
   
           //Calculate block of matrix used to calculate variance <H|Op|V>
            spncci::OperatorBlock operator_block;
            spncci::GetVarianceBlock(
              baby_spncci_space, observable_space,J0,
              spbasis_H, spbasis_V, lgi_pairs_HV, 
              observable_index, hw_index,operator_block
            );

            // std::cout<<"operator block"<<std::endl<<operator_block<<std::endl<<std::endl;
            spncci::OperatorBlock variance_block;
            const spncci::OperatorBlock& eigenvectors_J = eigenvectors[jp];
            CalculateVariance(eigenvectors_J,operator_block,variance_block);
            // std::cout<<"variance block"<<std::endl<<variance_block<<std::endl<<std::endl;
            // std::cout<<"eigenvectors "<<std::endl<<eigenvectors_J<<std::endl;
            // Store variances in vector 
            std::vector<double>& variances_J=variances[i][jp];
            variances_J.resize(eigenvectors_J.cols());
            std::cout<<"variances "<<variances_J.size()<<std::endl;
            for(int r=0; r<variances_J.size(); ++r)
            {
              variances_J[r]=variance_block(r,r);
              std::cout<<variances_J[r]<<std::endl;
            }
            
          }
        // std::cout<<"finished J sectors "<<std::endl;
      }
    // std::cout<<"finished variance function "<<std::endl;
  }

void DefineVarianceTruncatedSpace(
    const lgi::MultiplicityTaggedLGIVector& lgi_families,
    const spncci::BabySpNCCISpace& baby_spncci_space,
    const u3shell::ObservableSpaceU3S& observable_space,
    int observable_index, int hw_index, int J_index, int eigenvalue_index,
    // const std::vector<std::pair<int,int>>& sectors_J,
    spncci::RunParameters& run_parameters,
    int dominante_irrep_family_index
)
  {
    // set up J sectors for Hamiltonian
    std::vector<std::pair<int,int>> sectors_J;
    sectors_J.emplace_back(J_index,J_index);
    int J0=0; //for Hamiltonian

    // Set up H space 
    std::set<int> irrep_families_H; 
    irrep_families_H.insert(dominante_irrep_family_index);

    // Set up V space for each other irrep family
    std::vector<std::set<int>> list_irrep_families_V;
    for(int i=0; i<lgi_families.size(); ++i)
    // for(int i=0; i<3; ++i)
      {
        std::set<int> families;
        if(i==dominante_irrep_family_index)
          continue;

        families.insert(i);
        list_irrep_families_V.push_back(families);    
      }

    std::vector<std::vector<std::vector<double>>> variances;
    spncci::GetVariances(
      baby_spncci_space,observable_space,observable_index,
      hw_index,J0,sectors_J,run_parameters,
      irrep_families_H,list_irrep_families_V,variances
    );


    std::vector<std::vector<int>> irrep_families_by_variance(5); 
    for(int i=0; i<list_irrep_families_V.size(); ++i)
      {
        int irrep_family_index=*(list_irrep_families_V[i].begin()); //Only on index in set 
        double variance=variances[i][0][eigenvalue_index]; //Only 1 J values 
        if(variance>=100)
          irrep_families_by_variance[0].push_back(irrep_family_index);
        else if (variance>=10)
          irrep_families_by_variance[1].push_back(irrep_family_index); 
        else if (variance>=1)
          irrep_families_by_variance[2].push_back(irrep_family_index);
        else if (variance>1e-1)
          irrep_families_by_variance[3].push_back(irrep_family_index);
        else 
          irrep_families_by_variance[4].push_back(irrep_family_index);
      }

  }


}// end namespace

////////////////////////////////////////////////////////////////
// main body
////////////////////////////////////////////////////////////////

int main(int argc, char **argv)
{
  std::cout<<"entering spncci"<<std::endl;
  ////////////////////////////////////////////////////////////////
  // initialization
  ////////////////////////////////////////////////////////////////
  bool check_unit_tensors=false;

  // SU(3) caching
  u3::U3CoefInit();
  u3::g_u_cache_enabled = true;

  // parameters for certain calculations
  spncci::g_zero_tolerance = 1e-6;
  spncci::g_suppress_zero_sectors = true;

  // Default binary mode, unless environment variable SPNCCI_RME_MODE
  // set to "text".
  //
  // This is meant as an ad hoc interface until text mode i/o is abolished.
  lsu3shell::g_rme_binary_format = true;
  char* spncci_rme_mode_cstr = std::getenv("SPNCCI_RME_MODE");
  if (spncci_rme_mode_cstr!=NULL)
    {
      const std::string spncci_rme_mode = std::getenv("SPNCCI_RME_MODE");
      if (spncci_rme_mode=="text")
        lsu3shell::g_rme_binary_format = false;
    }

  // run parameters
  std::cout << "Reading control file..." << std::endl;
  spncci::RunParameters run_parameters;

  // Eigen OpenMP multithreading mode
  Eigen::initParallel();
  // Eigen::setNbThreads(0);

  // open output files
  std::ofstream results_stream("spncci.res");

  // results output: code information
  spncci::StartNewSection(results_stream,"CODE");
  spncci::WriteCodeInformation(results_stream,run_parameters);

  // results output: run parameters
  spncci::StartNewSection(results_stream,"PARAMETERS");
  spncci::WriteRunParameters(results_stream,run_parameters);

  std::cout<<"Nmax="<<run_parameters.Nmax<<std::endl;

  // /////////////////////////////////////////////////////////////////////////////////////
  // // set up SpNCCI space
  // ////////////////////////////////////////////////////////////////
  bool restrict_sp3r_to_u3_branching=false;
    if(run_parameters.A<6)
      restrict_sp3r_to_u3_branching=true;

  lgi::MultiplicityTaggedLGIVector lgi_families;
  spncci::SpNCCISpace spncci_space;
  spncci::SigmaIrrepMap sigma_irrep_map;
  spncci::BabySpNCCISpace baby_spncci_space;
  spncci::SpaceSpU3S spu3s_space;
  spncci::SpaceSpLS spls_space;
  spncci::SpaceSpJ spj_space;

  //Read in lgi families and generate spaces at different branching levels
  //Nlimit allows for different irreps to be truncated to different Nmax
  int Nlimit=run_parameters.Nmax;
  spncci::SetUpSpNCCISpaces(
      run_parameters,lgi_families,spncci_space,sigma_irrep_map,
      baby_spncci_space,spu3s_space,spls_space,spj_space,
      results_stream,Nlimit,restrict_sp3r_to_u3_branching
    );

  ///////////////////////////////////////////////////////////////////////////////////////////////////
  // Enumerate unit tensor space
  ///////////////////////////////////////////////////////////////////////////////////////////////////
  int J0_for_unit_tensors = -1;  // all J0
  int T0_for_unit_tensors = -1;  // all T0
  const bool restrict_positive_N0 = false;  // don't restrict to N0 positive

  // get full set of possible unit tensor labels up to Nmax, N1v truncation
  std::vector<u3shell::RelativeUnitTensorLabelsU3ST> unit_tensor_labels;
  u3shell::GenerateRelativeUnitTensorLabelsU3ST(
      run_parameters.Nmax, run_parameters.N1v,
      unit_tensor_labels,J0_for_unit_tensors,T0_for_unit_tensors,
      restrict_positive_N0
    );

  // for(auto tensor :unit_tensor_labels)
  //   std::cout<<tensor.Str()<<std::endl;

  // generate unit tensor subspaces
  u3shell::RelativeUnitTensorSpaceU3S
    unit_tensor_space(run_parameters.Nmax,run_parameters.N1v,unit_tensor_labels);

  ///////////////////////////////////////////////////////////////////////////////////////////////////
  //  Read in observables
  ///////////////////////////////////////////////////////////////////////////////////////////////////

  std::cout << "Reading observables..." << std::endl;

  // Initialize containers for rmes and their symmetries
  // Stored by hw, then by observable
  std::vector<std::vector<u3shell::RelativeRMEsU3SSubspaces>> observables_relative_rmes(run_parameters.hw_values.size());
  std::vector<std::vector<u3shell::IndexedOperatorLabelsU3S>> observable_symmetries_u3s(run_parameters.num_observables);

  spncci::ReadRelativeObservables(
      run_parameters.Nmax, run_parameters.N1v, run_parameters.hw_values,
      run_parameters.observable_directory,run_parameters.observable_filenames,
      unit_tensor_space, observables_relative_rmes, observable_symmetries_u3s
    );

  // Create observable spaces for each observable including Hamiltonian
  std::cout<<"create observable space"<<std::endl;
  std::vector<u3shell::ObservableSpaceU3S> observable_spaces(run_parameters.num_observables);
  for(int ob_num=0; ob_num<run_parameters.num_observables; ++ob_num)
      observable_spaces[ob_num]=u3shell::ObservableSpaceU3S(observable_symmetries_u3s[ob_num]);


  ////////////////////////////////////////////////////////////////
  // set up indexing for branching
  ////////////////////////////////////////////////////////////////
  std::cout << "Set up basis indexing for branching..." << std::endl;
  //////////////////////////////////////////////////////////////////
  // NEW BRANCHING
  //TODO: MAKE Vector with indices corresponding to run_parameters.J_values
  // vector be comes space with subspaces SpaceSpBasis in sectorsJ etcs.
  std::vector<spncci::SpaceSpBasis> spaces_spbasis(run_parameters.J_values.size());
  for(int j=0; j<run_parameters.J_values.size(); ++j)
    {
      const HalfInt& J=run_parameters.J_values[j];
      spaces_spbasis[j]=spncci::SpaceSpBasis(baby_spncci_space,J);
    }
  //////////////////////////////////////////////////////////////////
  // Testing 
  //////////////////////////////////////////////////////////////////
  // Generate list of irrep famlies in truncated space  
  std::set<int> irrep_family_subset;
  for (int i=0; i<3; ++i) irrep_family_subset.insert(i);  

  std::vector<spncci::SpaceSpBasis> spaces_spbasis_subset(run_parameters.J_values.size());
  for(int j=0; j<run_parameters.J_values.size(); ++j)
    {
      const HalfInt& J=run_parameters.J_values[j];
      spaces_spbasis_subset[j]=spncci::SpaceSpBasis(baby_spncci_space,J,irrep_family_subset);
      std::cout<<"J="<<J<<std::endl<<spaces_spbasis_subset[j].DebugStr()<<std::endl;
    }

//Will eventually remove.  For now just taking out of scope.
{
  ////////////////////////////////////////////////////////////////
  // Enumerate U3S sectors for observables
  ////////////////////////////////////////////////////////////////
  std::cout << "Enumerating u3s sectors..." << std::endl;

  // enumerate u3S space from baby spncci for each observable
  spncci::SpaceU3S space_u3s(baby_spncci_space);


  // Generate vector of hypersectors for each observable
  std::vector<spncci::ObservableHypersectorsU3S>
    observable_hypersectors_by_observable(run_parameters.num_observables);
  for(int ob_num=0; ob_num<run_parameters.num_observables; ++ob_num)
    observable_hypersectors_by_observable[ob_num]=spncci::ObservableHypersectorsU3S(space_u3s,observable_spaces[ob_num]);

  // Write observable u3s hypersector information to results file
  spncci::WriteU3SHypersectorSectorInformation(
      results_stream,space_u3s,run_parameters.num_observables,
      observable_hypersectors_by_observable
    );

  // // set up basis indexing for branching

  // determine J sectors for each observable
  std::vector<spncci::SectorsSpJ> observable_sectors;
  observable_sectors.resize(run_parameters.num_observables);

  for (int observable_index=0; observable_index<run_parameters.num_observables; ++observable_index)
    {
      const int J0=run_parameters.observable_J0_values[observable_index];
      observable_sectors[observable_index] = spncci::SectorsSpJ(spj_space,J0);
    }
}

  ////////////////////////////////////////////////////////////////
  // terminate counting only run
  ////////////////////////////////////////////////////////////////
  // We now have to do all termination manually.  But, when the
  // control code is properly refactored, we can just have a single
  // termination, and the rest of the run can be in an "if
  // (!count_only)"...

  if (run_parameters.count_only)
    {

      // termination
      results_stream.close();

      std::cout << "End of counting-only run" << std::endl;
      std::exit(EXIT_SUCCESS);
    }

  ////////////////////////////////////////////////////////////////
  // precompute K matrices
  ////////////////////////////////////////////////////////////////
  std::cout << "Precompute K matrices..." << std::endl;

  // timing start
  mcutils::SteadyTimer timer_k_matrices;
  timer_k_matrices.Start();

  // traverse distinct sigma values in SpNCCI space, generating K
  // matrices for each
  // spncci::KMatrixCache k_matrix_cache;
  spncci::KMatrixCache k_matrix_cache, kinv_matrix_cache;
  spncci::PrecomputeKMatrices(sigma_irrep_map,k_matrix_cache,kinv_matrix_cache,restrict_sp3r_to_u3_branching);

  // timing stop
  timer_k_matrices.Stop();
  std::cout << fmt::format("(Task time: {})",timer_k_matrices.ElapsedTime()) << std::endl;

  std::cout<<"Kmatrices "<<std::endl;
  for(auto it=k_matrix_cache.begin(); it!=k_matrix_cache.end(); ++it)
    {
      std::cout<<"sigma "<<it->first.Str()<<std::endl;
      for(auto it2=it->second.begin();  it2!=it->second.end(); ++it2)
      {
        std::cout<<"  omega"<<it2->first.Str()<<std::endl;
        auto matrix=it2->second;
        std::cout<<matrix<<std::endl;
        // std::cout<<matrix.inverse()<<std::endl;
      }
    }

  ///////////////////////////////////////////////////////////////////////////////////////////////
  std::cout<<"setting up lgi unit tensor blocks"<<std::endl;
  // Get list of unit tensor labels between lgi's
  std::vector<u3shell::RelativeUnitTensorLabelsU3ST> lgi_unit_tensor_labels;
  u3shell::GenerateRelativeUnitTensorLabelsU3ST(
      run_parameters.Nsigmamax, run_parameters.N1v,
      lgi_unit_tensor_labels,J0_for_unit_tensors,T0_for_unit_tensors,
      restrict_positive_N0
    );

  // //FOR TESTING
  // // explicit construction of spncci basis
  // basis::OperatorBlocks<double> spncci_expansions;
  // if(check_unit_tensors)
  //   spncci::ExplicitBasisConstruction(
  //     run_parameters,spncci_space,baby_spncci_space,
  //     k_matrix_cache, kinv_matrix_cache,
  //     restrict_sp3r_to_u3_branching,spncci_expansions
  //     );

  //Get look-up table for lgi index in full space.  Used for looking up seed filenames
  // which are index by full space index
  std::cout<<"reading lgi table "<<std::endl;
  std::vector<int> lgi_full_space_index_lookup;
  lgi::ReadLGILookUpTable(lgi_full_space_index_lookup,lgi_families.size());
  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  std::cout<<"Starting recurrence and contraction"<<std::endl;

  std::vector<spncci::LGIPair> lgi_pairs;
  spncci::GetLGIPairsForRecurrence(lgi_families,spncci_space,sigma_irrep_map,lgi_pairs);
  // lgi_pairs.emplace_back(0,0);

  spncci::ObservableHypersectorsByLGIPairTable
    observable_hypersectors_mesh(run_parameters.num_observables);

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // For debugging 
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // // by observable, by hw, by lgi pair
  // spncci::ObservableHyperblocksByLGIPairTable observable_hyperblocks_mesh(run_parameters.num_observables);

  // // Presize table
  // for(int observable_index=0; observable_index<run_parameters.num_observables; ++observable_index)
  //   observable_hyperblocks_mesh[observable_index].resize(run_parameters.hw_values.size());
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  
  //TODO: If doing change of basis for irrep families, read in transformation matrices
  spncci::OperatorBlocks lgi_transformations;

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // If transforming LGI basis
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  if(run_parameters.transform_lgi)
    {
      std::cout<<"reading in lgi transformations"<<std::endl;
      std::string lgi_transformations_filename="lgi_transformations.dat";
      spncci::ReadTransformationMatrices(lgi_transformations_filename,lgi_transformations);
      // for(int i=0; i<lgi_families.size(); ++i)
      //   {
      //     std::cout<<"---------------------------------------"<<std::endl;
      //     std::cout<<"irrep family "<<i<<std::endl;
      //     int j=lgi_full_space_index_lookup[i];
      //     std::cout<<"full space index "<<j<<std::endl;
      //     std::cout<<lgi_transformations[j]<<std::endl<<std::endl;
      //     std::cout<<"---------------------------------------"<<std::endl<<std::endl;
      //   }
    }
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
  std::cout<<"begin parallel region"<<std::endl;
  int num_files;
  // std::vector<int> num_lgi_pairs_per_thread;//For debugging contraction and branching
  #pragma omp parallel shared(observable_hypersectors_mesh,num_files)//,num_lgi_pairs_per_thread)
    {
      #pragma omp single
      {
        int num_threads=omp_get_num_threads();
        if(num_threads>lgi_pairs.size())
          {
            std::cout<<"Too many threads.  Only "<<lgi_pairs.size()<<" needed."<<std::endl;
            //TODO: reset num threads if necessary
            // Set num threads to one
            // omp_set_num_threads(1);

            assert(num_threads<=lgi_pairs.size());
          }
        // num_lgi_pairs_per_thread.resize(num_threads);// for debugging contraction and branching
        num_files=num_threads;
      }

      //coefficient caches
      u3::UCoefCache u_coef_cache;
      u3::PhiCoefCache phi_coef_cache;

      mcutils::SteadyTimer timer_recurrence;
      timer_recurrence.Start();

      #pragma omp for schedule(dynamic) nowait
      // for(int i=0; i<12; ++i)
      // Only observable hypersectors with irrep_family_bra>=irrep_family_ket written to files
      // If diagonal sector, only upper triangle stored.
      for(int i=0; i<lgi_pairs.size(); ++i)
        {
          const spncci::LGIPair& lgi_pair=lgi_pairs[i];

          spncci::ComputeManyBodyRMEs(
              run_parameters,lgi_families,lgi_full_space_index_lookup,
              spncci_space,baby_spncci_space,unit_tensor_space, observable_spaces,
              observables_relative_rmes,k_matrix_cache,kinv_matrix_cache,
              lgi_transformations,u_coef_cache,phi_coef_cache,lgi_pair
            );

          // num_lgi_pairs_per_thread[omp_get_thread_num()]++;// For debugging
          
        }// end lgi_pair

        timer_recurrence.Stop();

      //After recurrence completed, dealocate coefficient caches
      u_coef_cache.clear();
      phi_coef_cache.clear();

    } //end parallel region

  ////////////////////////////////////////////////////////////////
  // calculation mesh master loop
  ////////////////////////////////////////////////////////////////
  std::cout << "Calculation mesh master loop..." << std::endl;

  // timing start
  mcutils::SteadyTimer timer_mesh;
  timer_mesh.Start();

  // W coefficient cache -- needed for observable branching
  u3::WCoefCache w_cache;

  // for each hw value, solve eigen problem and get expectation values
  for(int hw_index=0; hw_index<run_parameters.hw_values.size(); ++hw_index)
    {

      ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      // Testing variance calculation
      ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      const u3shell::ObservableSpaceU3S& observable_space=observable_spaces[0];

      std::vector<std::pair<int,int>> sectors_J;
      for(int i=0; i<run_parameters.J_values.size(); ++i)
        sectors_J.emplace_back(i,i);

      std::set<int> irrep_families_H; 
      irrep_families_H.insert(3);
      irrep_families_H.insert(31);
      irrep_families_H.insert(88);
      irrep_families_H.insert(13);
      irrep_families_H.insert(28);
      irrep_families_H.insert(29);
      irrep_families_H.insert(0);
      irrep_families_H.insert(6);
      irrep_families_H.insert(78);
      irrep_families_H.insert(85);
      irrep_families_H.insert(89);
      irrep_families_H.insert(90);
      irrep_families_H.insert(92);
      irrep_families_H.insert(93);
      irrep_families_H.insert(95);
      irrep_families_H.insert(168);
      irrep_families_H.insert(175);
      irrep_families_H.insert(10);
      irrep_families_H.insert(11);
      irrep_families_H.insert(30);
      irrep_families_H.insert(32);
      irrep_families_H.insert(33);
      irrep_families_H.insert(34);
      irrep_families_H.insert(35);
      irrep_families_H.insert(58);
      irrep_families_H.insert(62);
      irrep_families_H.insert(63);
      irrep_families_H.insert(65);
      irrep_families_H.insert(82);
      irrep_families_H.insert(83);

      irrep_families_H.insert(26);
      irrep_families_H.insert(27);
      irrep_families_H.insert(77);
      irrep_families_H.insert(169);
      irrep_families_H.insert(170);

      irrep_families_H.insert(7);
      irrep_families_H.insert(8);
      irrep_families_H.insert(9);
      irrep_families_H.insert(24);
      irrep_families_H.insert(59);
      irrep_families_H.insert(60);
      irrep_families_H.insert(79);
      irrep_families_H.insert(80);
      irrep_families_H.insert(91);
      irrep_families_H.insert(138);
      irrep_families_H.insert(156);
      irrep_families_H.insert(158);
      irrep_families_H.insert(162);
      irrep_families_H.insert(162);
      irrep_families_H.insert(165);
      irrep_families_H.insert(171);



      std::vector<std::set<int>> list_irrep_families_V;
      // std::set<int> families;
      for(int i=0; i<lgi_families.size(); ++i)
      // for(int i=0; i<3; ++i)
        {
          std::set<int> families;
          if(irrep_families_H.count(i))
            continue;
          families.insert(i);
          list_irrep_families_V.push_back(families);    
        }

      std::cout<<"calculating variances"<<std::endl;
      std::vector<std::vector<std::vector<double>>> variances;
      spncci::GetVariances(
        baby_spncci_space, observable_space,0,hw_index,0,sectors_J,run_parameters,
        irrep_families_H,list_irrep_families_V,variances
      );

      // std::cout<<"printing variances "<<std::endl;
      // for(auto& variances_observable: variances)
      //   for(auto& variances_J :variances_observable)
      //     // for(double variance : variances_J)
      //       std::cout<<variances_J[0]<<std::endl;







      // retrieve mesh parameters
      double hw = run_parameters.hw_values[hw_index];

      // results output: log start of individual mesh calculation
      spncci::StartNewSection(results_stream,"RESULTS");
      spncci::WriteCalculationParameters(results_stream,hw);

      ////////////////////////////////////////////////////////////////
      // eigenproblem
      ////////////////////////////////////////////////////////////////

      std::cout<<"Solve eigenproblem..."<<std::endl;

      std::vector<spncci::Vector> eigenvalues(run_parameters.J_values.size());  // eigenvalues by J subspace
      std::vector<spncci::Matrix> eigenvectors(run_parameters.J_values.size());  // eigenvectors by J subspace

      // Construct and diagonalize Hamiltonian, do decompositions
      {
        const int observable_index = 0;  // for Hamiltonian
        for(int subspace_index=0; subspace_index<run_parameters.J_values.size(); ++subspace_index)
          {
            // for eigenproblem
            const HalfInt& J=run_parameters.J_values[subspace_index];
            spncci::Vector& eigenvalues_J = eigenvalues[subspace_index];
            spncci::Matrix& eigenvectors_J = eigenvectors[subspace_index];
            //////////////////////////////////////////////////////////////////
            // NEW BRANCHING
            //////////////////////////////////////////////////////////////////
            HalfInt J00 = run_parameters.observable_J0_values[observable_index];

            const spncci::SpaceSpBasis& spbasis_bra=spaces_spbasis[subspace_index];
            const spncci::SpaceSpBasis& spbasis_ket=spaces_spbasis[subspace_index];

            const u3shell::ObservableSpaceU3S& observable_space=observable_spaces[observable_index];

            spncci::OperatorBlock hamiltonian_matrix;
            spncci::ConstructSymmetricOperatorMatrix(
                baby_spncci_space,observable_space,
                J00,spbasis_bra,spbasis_ket,lgi_pairs,
                observable_index, hw_index,
                hamiltonian_matrix
              );

            // spncci::WriteMatrixToFile(hamiltonian_matrix, hw);
            // std::cout<<hamiltonian_matrix<<std::endl;
            // long int num_nonzero_rmes=0;
            // for(int i=0; i<hamiltonian_matrix.rows(); ++i)
            //   for(int j=0; j<=i; ++j)
            //     {
            //       if(fabs(hamiltonian_matrix(i,j))>10e-4)
            //         num_nonzero_rmes++;
            //     }
            // std::cout<<"number of non-zero rmes "<<num_nonzero_rmes<<std::endl;

            std::cout << fmt::format("  Diagonalizing: J={}",J) << std::endl;
            spncci::SolveHamiltonian(
                hamiltonian_matrix,
                run_parameters.num_eigenvalues,
                run_parameters.eigensolver_num_convergence,  // whatever exactly this is...
                run_parameters.eigensolver_max_iterations,
                run_parameters.eigensolver_tolerance,
                eigenvalues_J,eigenvectors_J
              );

            //////////////////////////////////////////////////////////////////
          }

        // results output: eigenvalues
        spncci::WriteEigenvalues(results_stream,run_parameters.J_values,eigenvalues,run_parameters.gex);


        //////////////////////////////////////////////////////////////
        // do decompositions
        ////////////////////////////////////////////////////////////////

        std::cout << "Calculate eigenstate decompositions..." << std::endl;
        mcutils::SteadyTimer timer_decompositions;
        timer_decompositions.Start();

        // decomposition matrices:
        //   - vector over J
        //   - matrix over (basis_subspace_index,eigenstate_index)
        //
        // That is, decompositions are stored as column vectors, within a
        // matrix, much like the eigenstates themselves.
        std::vector<spncci::Matrix> Nex_decompositions;
        std::vector<spncci::Matrix> baby_spncci_decompositions;
        Nex_decompositions.resize(run_parameters.J_values.size());
        baby_spncci_decompositions.resize(run_parameters.J_values.size());

        // calculate decompositions
        spncci::CalculateNexDecompositions(
          spaces_spbasis,eigenvectors,Nex_decompositions,
          run_parameters.Nsigma0,run_parameters.Nmax
        );

        spncci::CalculateBabySpNCCIDecompositions(
          spaces_spbasis,eigenvectors,baby_spncci_decompositions,
          baby_spncci_space.size()
        );

        timer_decompositions.Stop();
        std::cout << fmt::format("  (Decompositions: {})",timer_decompositions.ElapsedTime()) << std::endl;

        // // results output: decompositions
        spncci::WriteDecompositions(
          results_stream,"Nex",".6f",spaces_spbasis,
          Nex_decompositions,run_parameters.gex
        );

        spncci::WriteDecompositions(
          results_stream,"BabySpNCCI",".4e",spaces_spbasis,
          baby_spncci_decompositions,run_parameters.gex
        );

        ///////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Writing irrep family blocks to files for use in lgi basis transformation
        ///////////////////////////////////////////////////////////////////////////////////////////////////////////
        if(false) //TEMP While doing higher Nmax runs
        // if(not run_parameters.transform_lgi)
        {
          //TODO: Remove restriction to 3 and make input
          int num_eigenvalues=std::min(run_parameters.num_eigenvalues,3);
          std::cout<<"basis transformation "<<std::endl;
          int num_irrep_families=lgi_families.size();
          std::vector<std::vector<spncci::OperatorBlocks>> irrep_family_blocks;

          spncci::RegroupIntoIrrepFamilies(
            spaces_spbasis,num_irrep_families,num_eigenvalues,
            eigenvectors,irrep_family_blocks
          );

          std::string test_filename=fmt::format("irrep_family_blocks_{}",hw);
          spncci::WriteIrrepFamilyBlocks(
            run_parameters.J_values,  num_irrep_families,num_eigenvalues,
            lgi_full_space_index_lookup,irrep_family_blocks,test_filename
          );

        }
      }// End Hamiltonian section

// ////////////////////////////////////////////////////////////////////////////////////////////////////////////
      {
      //////////////////////////////////////////////////////////////
      // calculate observable RMEs
      ////////////////////////////////////////////////////////////////

      std::cout << "Calculate observable results..." << std::endl;
      mcutils::SteadyTimer timer_observables;
      timer_observables.Start();

      // observable_results_matrices:
      //   - vector over observable_index
      //   - vector over sector_index
      //   - matrix over (bra_eigenstate_index,ket_eigenstate_index)
      std::vector<spncci::OperatorBlocks> observable_results_matrices;
      observable_results_matrices.resize(run_parameters.num_observables);

      //Get sectors
      std::vector<std::vector<std::pair<int,int>>> observable_sectors(run_parameters.num_observables);
      for (int observable_index=0; observable_index<run_parameters.num_observables; ++observable_index)
        {
          auto& sectors=observable_sectors[observable_index];
          HalfInt J0 = run_parameters.observable_J0_values[observable_index];
          for(int i=0; i<run_parameters.J_values.size(); ++i)
            for(int j=0; j<run_parameters.J_values.size(); ++j)
              {
                HalfInt Jp=run_parameters.J_values[i];
                HalfInt J=run_parameters.J_values[j];
                if(am::AllowedTriangle(J,J0,Jp))
                  sectors.emplace_back(i,j);
              }
        }


      // std::cout<<"calculate observable results"<<std::endl;
      for (int observable_index=0; observable_index<run_parameters.num_observables; ++observable_index)
        {
          HalfInt J0 = run_parameters.observable_J0_values[observable_index];
          auto&sectors=observable_sectors[observable_index];

          observable_results_matrices[observable_index].resize(sectors.size());

          // std::cout<<"Get corresponding observable space"<<std::endl;
          const u3shell::ObservableSpaceU3S& observable_space=observable_spaces[observable_index];

          for(int sector_index=0; sector_index<sectors.size(); ++sector_index)
            {
              int bra_index,ket_index;
              std::tie(bra_index,ket_index)=sectors[sector_index];

              const spncci::SpaceSpBasis& spbasis_bra=spaces_spbasis[bra_index];
              const spncci::SpaceSpBasis& spbasis_ket=spaces_spbasis[ket_index];

              const HalfInt bra_J=run_parameters.J_values[bra_index];
              const HalfInt ket_J=run_parameters.J_values[ket_index];

              spncci::OperatorBlock observable_block;
              spncci::ConstructSymmetricOperatorMatrix(
                  baby_spncci_space,observable_space,
                  J0,spbasis_bra,spbasis_ket,lgi_pairs,
                  observable_index, hw_index,
                  observable_block
                );


              // // std::cout<<"constructing "<<std::endl;
              // spncci::OperatorBlock observable_block_test;
              // spncci::ConstructOperatorMatrix(
              //   baby_spncci_space,observable_space,J0,
              //   // w_cache,
              //   spbasis_bra, spbasis_ket,
              //   num_lgi_pairs_per_thread,observable_index, hw_index,observable_block_test
              // );

              // std::cout<<"comparison "<<std::endl;
              // if(not mcutils::IsZero((observable_block-observable_block_test),1e-4))
              //   {
              //     spncci::OperatorBlock diff=(observable_block-observable_block_test);
              //     mcutils::ChopMatrix(diff,1e-4);
              //     std::cout<<diff<<std::endl<<std::endl;
              //     // std::cout<<observable_block_test<<std::endl<<std::endl;
              //   }
              // else
              //   std::cout<<"  observables matrices match"<<std::endl;


              std::cout<<"calculate observable results"<<std::endl;
              Eigen::MatrixXd& observable_results_matrix = observable_results_matrices[observable_index][sector_index];
              observable_results_matrix = eigenvectors[bra_index].transpose()
                * observable_block
                * eigenvectors[ket_index];


              std::cout
                << fmt::format("Observable {} bra_J {} ket_J {}",observable_index,bra_J,ket_J)
                << std::endl;
            }
        }

      // end timing
      timer_observables.Stop();
      std::cout << fmt::format("  (Observables: {})",timer_observables.ElapsedTime()) << std::endl;

      // results output: observables

      spncci::WriteObservables(
        results_stream,run_parameters.J_values,observable_sectors,
        observable_results_matrices,run_parameters.gex
      );

      }//observable

    // ////////////////////////////////////////////////////////////////////////////////////////////////////////////
  }

// timing stop
timer_mesh.Stop();
std::cout << fmt::format("(Mesh master loop: {})",timer_mesh.ElapsedTime()) << std::endl;

results_stream.close();


}
