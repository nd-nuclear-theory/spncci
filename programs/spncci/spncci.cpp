/****************************************************************
  spncci.cpp

  Tests of explicit SpNCCI basis construction in LSU3Shell basis.

  This code just tests normalization, but using clean refactored
  infrastructure.  Other deeper tests (of unit tensor matrix elements)
  were carried out in compute_unit_tensor_rmes.cpp.

  Required data:

  * Relative operator lsu3shell rme input files are generated by

      generate_lsu3shell_relative_operators.cpp

    which is invoked through scripting in

      compute_relative_tensors_lsu3shell_rmes.py

    Example: Z=3 N=3 twice_Nsigma0=22 Nmax=2 Nstep=2 N1v[=N1b]=1
   
    % python3 script/compute_relative_tensors_lsu3shell_rmes.py 3 3 22 2 2 1

    Only need .rme and .dat files.

    Not saved to repository since ~3.5 Mb...

       data/lsu3shell/lsu3shell_rme_6Li_Nmax02
    
  * Relative Hamiltonian (and observable) upcoupled rme files are
    generated by

      generate_relative_u3st_operators

    which is invoked manually for now as

      generate_relative_u3st_operators A Nmax N1v basename

   Example:

       ../operators/generate_relative_u3st_operators 6 2 1 hamiltonian

       with hamiltonian.load containing

       20    // hw
       Tintr 1.0    // coef
       INT 1.0 4 0 0 0 relative_observables/JISP16_Nmax20_hw20.0_rel.dat      // coef Jmax J0 T0 g0 interaction_filename

       ../operators/generate_relative_u3st_operators 6 2 1 Nintr

       with Nintr.load containing

       20    // hw
       Nintr 1.0    // coef

       ../operators/generate_relative_u3st_operators 6 2 1 r2intr

       with r2intr.load containing

       20    // hw
       r2intr 1.0    // coef

   % ln -s ../../data/relative_observables/

         
     

  Anna E. McCoy and Mark A. Caprio
  University of Notre Dame

  2/20/17 (mac): Created (starting from explicit.cpp).
****************************************************************/

#include <cstdio>
#include <ctime>
#include <fstream>
#include <sys/resource.h>

#include "SymEigsSolver.h"  // from spectra

#include "cppformat/format.h"
#include "mcutils/parsing.h"
#include "lgi/lgi_solver.h"
#include "mcutils/profiling.h"
// #include "spncci/computation_control.h"
#include "spncci/explicit_construction.h"
#include "spncci/io_control.h"
#include "spncci/branching_u3s.h"
#include "spncci/branching_u3lsj.h"
// to vett as moved into computation_control 
#include "mcutils/eigen.h"

////////////////////////////////////////////////////////////////
// WIP code
//
// to extract to spncci library when ready
////////////////////////////////////////////////////////////////
  
namespace spncci
{
 
  void
  ReadAndTransformSeedUnitTensorRMEs(
      const lsu3shell::LSU3BasisTable& lsu3shell_basis_table,
      const u3shell::SpaceU3SPN& lsu3shell_space, 
      const basis::MatrixVector& lgi_expansions,
      const u3shell::RelativeUnitTensorLabelsU3ST& unit_tensor_labels,
      const std::string& filename,
      u3shell::SectorsU3SPN& unit_tensor_sectors,
      basis::MatrixVector& unit_tensor_spncci_matrices
    )
  {
    
    // lgi_unit_tensor_spncci_matrices.resize(lgi_unit_tensor_labels.size());
    // for (int unit_tensor_index=0; unit_tensor_index<lgi_unit_tensor_labels.size(); ++unit_tensor_index)
    //   {
        // set up aliases for current unit tensor
        // const u3shell::RelativeUnitTensorLabelsU3ST& unit_tensor_labels = lgi_unit_tensor_labels[unit_tensor_index];
        // const u3shell::SectorsU3SPN& unit_tensor_sectors = lgi_unit_tensor_sectors[unit_tensor_index];
        // const basis::MatrixVector& unit_tensor_lsu3shell_matrices = lgi_unit_tensor_lsu3shell_matrices[unit_tensor_index];
        // basis::MatrixVector& unit_tensor_spncci_matrices = lgi_unit_tensor_spncci_matrices[unit_tensor_index];
      
    const bool spin_scalar = false;

    // generate sector labels 
    unit_tensor_sectors = u3shell::SectorsU3SPN(lsu3shell_space,unit_tensor_labels,spin_scalar);
    
    // read in lsu3shell rms for unit tensor 
    basis::MatrixVector unit_tensor_lsu3shell_matrices;
    lsu3shell::ReadLSU3ShellRMEs(
        filename,
        lsu3shell_basis_table,lsu3shell_space,
        unit_tensor_labels,unit_tensor_sectors,unit_tensor_lsu3shell_matrices
      );

    // transform seed rmes to SpNCCI basis (among LGIs)
    lgi::TransformOperatorToSpBasis(
        unit_tensor_sectors,lgi_expansions,
        unit_tensor_lsu3shell_matrices,unit_tensor_spncci_matrices
      );
      // }
  } 



void
  GenerateRecurrenceUnitTensors(
      int Nmax,
      const std::set<int>& lgi_operator_subset,
      const u3shell::RelativeUnitTensorSpaceU3S& unit_tensor_space,
      std::map<spncci::NnPair,std::set<int>>& operator_subsets,
      bool include_zero
      // std::map<int,int>& seed_unit_tensor_lookup_table
    )
  // for a single irrep pair
  // if i_bra<=i_ket, then keep all unit tensors with N0<=0
  // if i_bra>i_ket, then keep only unit tensors with N0<0
  // The remaining hypersectors will be obtained by symmetry relations 
  // (-1)^()<i_bra|| || i_ket>=<i_ket|| || i_bra>
  {
    std::cout<<"Entering Generate Recurrence Unit Tensors "<<std::endl;

    u3::SU3 x0; 
    HalfInt S0;
    int etap,eta;

    // Initialize with values from lgi_operator_subset
    std::set<int>& operator_subset=operator_subsets[spncci::NnPair(0,0)];
    for(int unit_tensor_subspace_index : lgi_operator_subset)
        operator_subset.insert(unit_tensor_subspace_index);

    // If is an include N0=0 lgi pair, then the max value of N0=0, 
    // otherwise, N0<0, i.e., N0<=-1
    int N0_max=include_zero?0:-1;

    // Generate non-lgi unit tensor family labels 
    for(int Nsum=0; Nsum<=2*Nmax; Nsum+=2)
      for(int Nn=0; Nn<=std::min(Nsum,Nmax); Nn+=2)
        {
          int Nnp=Nsum-Nn;
          if((Nnp<0)||(Nnp>Nmax))
            continue;


          // If not the seed sector, and N0>N0_max, got to next sector
          if( ((Nnp-Nn)>N0_max) && Nsum!=0)
            continue;


          spncci::NnPair NnpNn2(Nnp,Nn+2);
          // For each source unit tensor, generate related unit tensors in Nnp,Nn+2 sector and Nnp+2,Nn+2 sector
          const std::set<int>& source_operator_subspace_indices=operator_subsets[spncci::NnPair(Nnp,Nn)];
          for(int source_operator_subspace_index : source_operator_subspace_indices)
            {
              
              std::tie(x0,S0,etap,eta)=unit_tensor_space.GetSubspace(source_operator_subspace_index).labels();
              
              // Check if a valid target sector    
              if((Nnp-Nn-2)<=N0_max)
                {
                  // if etap-2 is negative, then not a valid value
                  if((etap-2)>=0)
                    {
                      MultiplicityTagged<u3::SU3>::vector x0p_set1=KroneckerProduct(u3::SU3(etap-2,0), u3::SU3(0,eta));
                      for(auto& x0p_tagged : x0p_set1)
                        {
                          u3::SU3 x0p(x0p_tagged.irrep);
                          u3shell::UnitTensorSubspaceLabels unit_tensor_subspace_labels(x0p,S0,etap-2,eta);
                          int operator_subspace_index=unit_tensor_space.LookUpSubspaceIndex(unit_tensor_subspace_labels);
                          // std::cout<<"hi "<<operator_subspace_index<<std::endl;
                          if(operator_subspace_index!=-1)
                            operator_subsets[NnpNn2].insert(operator_subspace_index);

                        }
                    } 
                  MultiplicityTagged<u3::SU3>::vector x0p_set2=KroneckerProduct(u3::SU3(etap,0), u3::SU3(0,eta+2)); 
                  for(auto& x0p_tagged : x0p_set2)
                    {
                      u3::SU3 x0p(x0p_tagged.irrep);
                      u3shell::UnitTensorSubspaceLabels unit_tensor_subspace_labels(x0p,S0,etap,eta+2);
                      // std::cout<<x0p.Str()<<"  "<<etap<<"  "<<eta+2<<std::endl;
                      int operator_subspace_index=unit_tensor_space.LookUpSubspaceIndex(unit_tensor_subspace_labels);
                      // std::cout<<"jo "<<operator_subspace_index<<std::endl;
                      if(operator_subspace_index!=-1)
                        operator_subsets[NnpNn2].insert(operator_subspace_index);
                    }
                }

              // Add tensor to Nnp+2,Nn+2 target sector.  Will be valid if Nnp,Nn is valid sector 
              operator_subsets[spncci::NnPair(Nnp+2,Nn+2)].insert(source_operator_subspace_index);
              std::cout<<"operator_subsets "<<Nnp<<"  "<<Nn<<"  "<<source_operator_subspace_index<<std::endl;
            }
        }
  }


  void
  WriteEigenValues(
    const std::vector<HalfInt>& J_values, double hw, 
    int Nmax, int Nsigma0_ex_max,
    std::map<HalfInt,Eigen::VectorXd>& eigenvalues,
    std::vector<std::string>& observable_filenames,
    std::vector<int>& scalar_observable_indices,
    std::vector<std::map<HalfInt,Eigen::VectorXd>>& scalar_observable_expectations,
    std::vector<int>& nonscalar_observable_indices,
    std::vector<std::map<spncci::JPair,Eigen::MatrixXd>>& nonscalar_observable_expectations
  )
  // for observables with J0=0, line them up with energy eigenvalue and read off diagonal matrix elements 
  // for observables with J0!=0, then have their own section --probably do this in the code as well, i.e.,
  {
    std::string filename=fmt::format("eigenvalues_Nmax{:02d}_Nsigma_ex{:02d}.dat",Nmax,Nsigma0_ex_max);
    std::cout<<"writing to file"<<std::endl;
    std::fstream fs;
    const int width=3;
    const int precision=16;
    fs.open (filename, std::fstream::out | std::fstream::app);
    fs << std::setprecision(precision);

    fs << "OUPTPUT from spncci Version 1"<<std::endl<<std::endl;;
    fs << "Scalar observables:";
    for(int i=0; i<scalar_observable_indices.size(); ++i)
      fs <<"  "<<observable_filenames[scalar_observable_indices[i]];
    fs << std::endl;

    fs <<"Nonscalar observables:";
    for(int i=0; i<nonscalar_observable_indices.size(); ++i)
      fs <<"  "<<observable_filenames[nonscalar_observable_indices[i]];

    fs << std::endl<<fmt::format("hw {:2.1f}", hw)<<std::endl;

    for(HalfInt J : J_values)
      {
        Eigen::VectorXd& eigenvalues_J=eigenvalues[J];
        // Eigen::VectorXd& observables=observable_expectations[J];

        for(int i=0; i<eigenvalues_J.size(); ++i)
          {
            double eigenvalue=eigenvalues_J(i);
            std::cout<<fmt::format("{:2d}   {}   {:8.5f}",i, J,eigenvalue);
            fs << fmt::format("{:2d}   {}   {:8.5f}",i, J,eigenvalue);
            
            for(int j=0; j<scalar_observable_indices.size(); ++j)  
            {          
              std::cout<<fmt::format("   {:8.5f}",scalar_observable_expectations[j][J](i))
              <<std::endl<<std::endl;
              fs <<fmt::format("   {:8.5f}",scalar_observable_expectations[j][J](i))
              <<std::endl<<std::endl;
            }
          }
      }
    for(HalfInt J : J_values)
      {
        Eigen::VectorXd& eigenvalues_J_initial=eigenvalues[J];
        for(int i=0; i<eigenvalues_J_initial.size(); ++i)
          for(HalfInt Jp :J_values)
          {
            Eigen::VectorXd& eigenvalues_J_final=eigenvalues[Jp];
            spncci::JPair J_pair(Jp,J);
            for(int ip=0; ip<eigenvalues_J_final.size(); ++ip)
              {
                double eigenvalue_initial=eigenvalues_J_initial(i);
                double eigenvalue_final=eigenvalues_J_final(ip);
                fs << fmt::format("{:2d}   {}   {:2d}   {}   {:8.5f}   {:8.5f}",
                      i,J,ip,Jp,eigenvalue_initial,eigenvalue_final);

                for(int j=0; j<nonscalar_observable_indices.size(); ++j)
                  {
                    // std::cout<<"(ip, i) ("<<ip<<","<<i<<")"<<std::endl;
                    Eigen::MatrixXd& obserable_matrix=nonscalar_observable_expectations[j][J_pair];
                    // std::cout<<obserable_matrix<<std::endl;
                    double observable=obserable_matrix(ip,i);
                    fs<<fmt::format("  {:8.5f}",observable);
                  }
                fs<<std::endl;
              }
          }
      }
    fs<<std::endl<<std::endl;
    fs.close();
  }

}// end namespace

////////////////////////////////////////////////////////////////
// run parameters
////////////////////////////////////////////////////////////////

struct RunParameters
// Structure to store input parameters for run.
//
// Data members:
//   A (int): Atomic mass.
//   ...
{

  // constructor
  RunParameters(int argc, char **argv); 

  // basis parameters
  int A;
  HalfInt Nsigma_0;
  int Nsigma0_ex_max;
  int N1v;
  int Nmax;

  // filenames
  std::string lsu3shell_rme_directory;
  std::string lsu3shell_basis_filename;
  std::string Brel_filename;
  std::string Arel_filename;
  std::string Nrel_filename;
  std::string relative_unit_tensor_filename_template;

  // many-body problem
  std::string observable_directory;
  std::vector<std::string> observable_filenames;  // first observable is used as Hamiltonian
  std::vector<int> observable_Jvalues;
  int num_observables;
  std::vector<HalfInt> J_values;
  std::vector<double> hw_values;

  // eigensolver
  int num_eigenvalues;
  int eigensolver_num_convergence;  // whatever exactly this is...
  int eigensolver_max_iterations;
  double eigensolver_tolerance;

};

RunParameters::RunParameters(int argc, char **argv)
{
  // read from command line arguments
  //
  // TODO reorder filenames 
  if (argc<5)
    {
      std::cout << "Syntax: A twice_Nsigma0 Nsigma0_ex_max N1v Nmax num_eigenvalues <load file>"
       // <basis filename> <Nrel filename> <Brel filename> <Arel filename>" 
                << std::endl;
      std::exit(1);
    }
  A = std::stoi(argv[1]); 
  int twice_Nsigma0= std::stoi(argv[2]);
  Nsigma0_ex_max=std::stoi(argv[3]);
  Nsigma_0=HalfInt(twice_Nsigma0,2);
  N1v=std::stoi(argv[4]);
  Nmax = std::stoi(argv[5]);
  num_eigenvalues=std::stoi(argv[6]);
  std::string load_file=argv[7];

  // std::cout<< fmt::format("{} {} {} {} {} {}",A, twice_Nsigma0, Nsigma_0, Nsigma0_ex_max, N1v, Nmax)<<std::endl;
  
  // many-body problem
  // observable_filenames = std::vector<std::string>({"hamiltonian_u3st.dat"});

  // Reading in from load life 
  int line_count=0;
  int twice_Jmin, twice_Jmax, J_step;
  double hw_min, hw_max, hw_step;
  std::string line, observable;
  std::ifstream is(fmt::format("{}.load",load_file));
  
  assert(is);
  int J0;
  while(std::getline(is,line))
    {
      std::istringstream line_stream(line);
      ++line_count;
      if(line_count==1)
      {
        line_stream >> twice_Jmin >> twice_Jmax >> J_step;
        ParsingCheck(line_stream,line_count,line);
      }
      else if(line_count==2)
      {
        line_stream >> hw_min >> hw_max >> hw_step;
        ParsingCheck(line_stream,line_count,line);
      }
      else
      {
        line_stream >> observable >> J0;
        ParsingCheck(line_stream,line_count,line);
        observable_filenames.push_back(observable);
        observable_Jvalues.push_back(J0);
      }
    }

  num_observables = observable_filenames.size();
  observable_directory="relative_observables";
  // generate list of J values 
  HalfInt Jmin(twice_Jmin,2);
  HalfInt Jmax(twice_Jmax,2);
  for(HalfInt J=Jmin; J<=Jmax; J+=J_step)
    J_values.push_back(J);

  std::cout<<"J values are: ";
  for(auto J : J_values)
    std::cout<<J<<"  ";
  std::cout<<std::endl;

  for(double hw=hw_min; hw<=hw_max; hw+=hw_step)
    hw_values.push_back(hw);

  std::cout<<"hw values are: ";
  for(auto hw : hw_values)
    std::cout<<hw<<"  ";
  std::cout<<std::endl;


  // hard-coded directory structure and filenames
  lsu3shell_rme_directory = "lsu3shell_rme";
  lsu3shell_basis_filename = lsu3shell_rme_directory + "/" + "lsu3shell_basis.dat";
  Brel_filename = lsu3shell_rme_directory + "/" + fmt::format("Brel_06_Nmax{:02d}.rme",Nsigma0_ex_max);
  Arel_filename = lsu3shell_rme_directory + "/" + fmt::format("Arel_06_Nmax{:02d}.rme",Nsigma0_ex_max);
  Nrel_filename = lsu3shell_rme_directory + "/" + fmt::format("Nrel_06_Nmax{:02d}.rme",Nsigma0_ex_max);
  relative_unit_tensor_filename_template = lsu3shell_rme_directory + "/" + "relative_unit_{:06d}.rme";

  // hard-coded eigen solver parameters   
  eigensolver_num_convergence = 2*num_eigenvalues;    // docs for SymEigsSolver say to take "ncv>=2*nev"
  eigensolver_max_iterations = 100*num_eigenvalues;
  eigensolver_tolerance = 1e-8;
}


////////////////////////////////////////////////////////////////
// main body
////////////////////////////////////////////////////////////////

int main(int argc, char **argv)
{
  std::cout<<"entering spncci"<<std::endl;
  ////////////////////////////////////////////////////////////////
  // initialization
  ////////////////////////////////////////////////////////////////
  
  // SU(3) caching
  u3::U3CoefInit();
  u3::UCoefCache u_coef_cache;
  u3::PhiCoefCache phi_coef_cache;
  u3::g_u_cache_enabled = true;

  // numerical parameter for certain calculations
  double zero_threshold=1e-8;  // DEPRECATED but still may be used some places
  spncci::g_zero_tolerance = 1e-6;
  spncci::g_suppress_zero_sectors = true;

  // run parameters
  RunParameters run_parameters(argc,argv);

  // Eigen OpenMP multithreading mode
  Eigen::initParallel();
  // Eigen::setNbThreads(0);

  ////////////////////////////////////////////////////////////////
  // read lsu3shell basis
  ////////////////////////////////////////////////////////////////

  std::cout << "Read lsu3shell basis..." << std::endl;
  // read lsu3shell basis (regroup into U3SPN subspaces)
  lsu3shell::LSU3BasisTable lsu3shell_basis_table;
  lsu3shell::U3SPNBasisLSU3Labels lsu3shell_basis_provenance;
  u3shell::SpaceU3SPN lsu3shell_space;
  lsu3shell::ReadLSU3Basis(
      run_parameters.Nsigma_0,run_parameters.lsu3shell_basis_filename,
      lsu3shell_basis_table,lsu3shell_basis_provenance,lsu3shell_space
    );

  ////////////////////////////////////////////////////////////////
  // solve for LGIs
  ////////////////////////////////////////////////////////////////
  std::cout << "Solve for LGIs..." << std::endl;

  // timing start
  Timer timer_lgi;
  timer_lgi.Start();

  u3shell::SectorsU3SPN Brel_sectors, Arel_sectors, Nrel_sectors;
  basis::MatrixVector Brel_matrices, Arel_matrices, Nrel_matrices;
  spncci::ReadLSU3ShellSymplecticOperatorRMEs(
      lsu3shell_basis_table,lsu3shell_space, 
      run_parameters.Brel_filename,Brel_sectors,Brel_matrices,
      run_parameters.Arel_filename,Arel_sectors,Arel_matrices,
      run_parameters.Nrel_filename,Nrel_sectors,Nrel_matrices
    );

  const u3shell::SectorsU3SPN& Ncm_sectors = Nrel_sectors;
  basis::MatrixVector Ncm_matrices;
  lsu3shell::GenerateLSU3ShellNcmRMEs(
      lsu3shell_space,Nrel_sectors,Nrel_matrices,
      run_parameters.A,
      Ncm_matrices
    );

  lgi::MultiplicityTaggedLGIVector lgi_families;
  basis::MatrixVector lgi_expansions;
  // bool keep_zero_sectors=true;
  lgi::GenerateLGIExpansion(
      lsu3shell_space, 
      Brel_sectors,Brel_matrices,Ncm_sectors,Ncm_matrices,
      run_parameters.Nsigma_0,
      lgi_families,lgi_expansions
      // keep_zero_sectors
    );

  // diagnostics
  std::cout << fmt::format("  LGI families {}",lgi_families.size()) << std::endl;
  if (false)
    lgi::WriteLGILabels(lgi_families,std::cout);

  // timing stop
  timer_lgi.Stop();
  std::cout << fmt::format("(Task time: {})",timer_lgi.ElapsedTime()) << std::endl;

  ////////////////////////////////////////////////////////////////
  // set up SpNCCI space
  ////////////////////////////////////////////////////////////////

  std::cout << "Set up SpNCCI space..." << std::endl;

  // build SpNCCI irrep branchings
  spncci::SpNCCISpace spncci_space;
  spncci::SigmaIrrepMap sigma_irrep_map;  // persistent container to store branchings
  spncci::NmaxTruncator truncator(run_parameters.Nsigma_0,run_parameters.Nmax);
  spncci::GenerateSpNCCISpace(lgi_families,truncator,spncci_space,sigma_irrep_map);

  // diagnostics
  std::cout << fmt::format("  Irrep families {}",spncci_space.size()) << std::endl;
  std::cout << fmt::format("  TotalU3Subspaces {}",spncci::TotalU3Subspaces(spncci_space)) << std::endl;
  std::cout << fmt::format("  TotalDimensionU3 {}",spncci::TotalDimensionU3S(spncci_space)) << std::endl;


  // build SpNCCI irrep branchings for LGI's
  spncci::SpNCCISpace lgi_spncci_space;
  spncci::SigmaIrrepMap lgi_sigma_irrep_map;  // persistent container to store branchings
  spncci::NmaxTruncator lgi_truncator(run_parameters.Nsigma_0,run_parameters.Nsigma0_ex_max);
  spncci::GenerateSpNCCISpace(lgi_families,lgi_truncator,lgi_spncci_space,lgi_sigma_irrep_map);


  ////////////////////////////////////////////////////////////////
  // precompute K matrices
  ////////////////////////////////////////////////////////////////

  std::cout << "Precompute K matrices..." << std::endl;

  // timing start
  Timer timer_k_matrices;
  timer_k_matrices.Start();

  // traverse distinct sigma values in SpNCCI space, generating K
  // matrices for each
  spncci::KMatrixCache k_matrix_cache;
  bool intrinsic = true;
  spncci::PrecomputeKMatrices(sigma_irrep_map,k_matrix_cache,intrinsic);

  // timing stop
  timer_k_matrices.Stop();
  std::cout << fmt::format("(Task time: {})",timer_k_matrices.ElapsedTime()) << std::endl;

  ///////////////////////////////////////////////////////////////////////////////////////////////////
  // Enumerate unit tensor space 
  ///////////////////////////////////////////////////////////////////////////////////////////////////
  // build baby spncci space 
  spncci::BabySpNCCISpace baby_spncci_space(spncci_space);

  int J0_for_unit_tensors = -1;  // all J0
  int T0_for_unit_tensors = -1;  // all T0
  const bool restrict_positive_N0 = false;  // don't restrict to N0 positive

  // get full set of possible unit tensor labels up to Nmax, N1v truncation
  std::vector<u3shell::RelativeUnitTensorLabelsU3ST> unit_tensor_labels;  
  u3shell::GenerateRelativeUnitTensorLabelsU3ST(
    run_parameters.Nmax, run_parameters.N1v,
    unit_tensor_labels,J0_for_unit_tensors,T0_for_unit_tensors,
    restrict_positive_N0
    );

  for(auto tensor :unit_tensor_labels)
    std::cout<<tensor.Str()<<std::endl;

  // generate unit tensor subspaces 
  u3shell::RelativeUnitTensorSpaceU3S 
    unit_tensor_space(run_parameters.Nmax,run_parameters.N1v,unit_tensor_labels);


  ///////////////////////////////////////////////////////////////////////////////////////////////////
  //  For testing, get lsu3shell expansion of full spncci basis
  ///////////////////////////////////////////////////////////////////////////////////////////////////        
  basis::MatrixVector spncci_expansions;
  spncci::ConstructSpNCCIBasisExplicit(
      lsu3shell_space,spncci_space,lgi_expansions,baby_spncci_space,
      k_matrix_cache,Arel_sectors,Arel_matrices,spncci_expansions
    );

  ///////////////////////////////////////////////////////////////////////////////////////////////////
  //  Read in observables  
  ///////////////////////////////////////////////////////////////////////////////////////////////////        
  std::cout << "Read observable relative rmes..." << std::endl;
  std::vector<std::vector<u3shell::RelativeRMEsU3SSubspaces>> observables_relative_rmes(run_parameters.num_observables);
  
  std::vector<std::vector<u3shell::IndexedOperatorLabelsU3S>> observable_symmetries_u3s(run_parameters.num_observables); 
  // for each observable at the give hbar omega
  for (int observable_index=0; observable_index<run_parameters.num_observables; ++observable_index)
    {
      std::vector<u3shell::RelativeRMEsU3SSubspaces>&
         observable_relative_rmes=observables_relative_rmes[observable_index];
        
      observable_relative_rmes.resize(run_parameters.hw_values.size());      
      
      // temporary container 
      std::unordered_set<u3shell::IndexedOperatorLabelsU3S, boost::hash<u3shell::IndexedOperatorLabelsU3S>> symmetries_u3s;
      
      // for each value of hbar omega
      for(int h=0; h<run_parameters.hw_values.size(); ++h)
        {
          double hw=run_parameters.hw_values[h];

          std::string observable_filename=fmt::format("{}/{}_hw{:2.1f}_Nmax{:02d}_u3st.dat", 
              run_parameters.observable_directory,
              run_parameters.observable_filenames[observable_index],hw,run_parameters.Nmax);

          std::cout << fmt::format("  Reading {}...",observable_filename)<< std::endl;

          u3shell::RelativeRMEsU3SSubspaces& relative_rmes=observable_relative_rmes[h];
          u3shell::ReadRelativeOperatorU3ST(run_parameters.Nmax, run_parameters.N1v,observable_filename,unit_tensor_space,relative_rmes);
          std::cout<<"finished reading "<<std::endl;
          // turn into function
          for(auto it=relative_rmes.begin(); it!=relative_rmes.end(); ++it)
            {
              int unit_tensor_subspace_index, kappa0,L0,etap,eta;
              HalfInt S0;
              u3::SU3 x0;
              std::tie(unit_tensor_subspace_index,kappa0,L0)=it->first;
              std::tie(x0,S0,etap,eta)=unit_tensor_space.GetSubspace(unit_tensor_subspace_index).labels();
              symmetries_u3s.insert(u3shell::IndexedOperatorLabelsU3S(u3shell::OperatorLabelsU3S(etap-eta,x0,S0),kappa0,L0));
            }
          std::cout<<"got the symmetries "<<std::endl;
        }
      std::cout<<"put the tensors in the vector"<<std::endl;
      for(auto tensor : symmetries_u3s)
        observable_symmetries_u3s[observable_index].push_back(tensor);
    }

  // set up U3S sectors for each of the observables 
  // Was the function ConstructObservablesU3S
  ///////////////////////////////////////////////////////////////////////////////////////////////
  std::cout<<"setting up u3 sectors "<<std::endl;
  // enumerate u3S space from baby spncci for each observable 
  spncci::SpaceU3S space_u3s(baby_spncci_space);

  // vector of sectors for each observable
  std::vector<std::vector<spncci::SectorLabelsU3S>> observables_sectors_u3s(run_parameters.num_observables);

  // vector of blocks for u3 sectors for each observable, for each hbar omega
  std::vector<std::vector<basis::OperatorBlocks<double>>> observables_blocks_u3s(run_parameters.num_observables);

  // for each observable, enumerate sectors 

  for(int observable_index=0; observable_index< run_parameters.num_observables; ++observable_index) 
    {
      std::vector<spncci::SectorLabelsU3S>& sectors_u3s=observables_sectors_u3s[observable_index];
      spncci::GetSectorsU3S(space_u3s,observable_symmetries_u3s[observable_index],sectors_u3s);
      std::vector<basis::OperatorBlocks<double>>& observable_blocks_u3s=observables_blocks_u3s[observable_index];
      observable_blocks_u3s.resize(run_parameters.hw_values.size());
      
      // zero initialize each block
      for(int h=0; h<run_parameters.hw_values.size(); ++h)
        // based on SetOperatorToZero in basis library operator.h
        // will replace with template function when u3sectors converted to hypersectors 
        {
          basis::OperatorBlocks<double>& blocks=observable_blocks_u3s[h];
          blocks.resize(sectors_u3s.size());
          for(int sector_index=0; sector_index<sectors_u3s.size(); ++sector_index)
            {
              int rows=space_u3s.GetSubspace(sectors_u3s[sector_index].bra_index()).sector_dim();
              int cols=space_u3s.GetSubspace(sectors_u3s[sector_index].ket_index()).sector_dim();
              blocks[sector_index]=basis::OperatorBlock<double>::Zero(rows,cols);
            }
        }

    } 
  ///////////////////////////////////////////////////////////////////////////////////////////////
  std::cout<<"seting up lgi unit tensor blocks"<<std::endl;
  
  // map of {lgi pair : list of hypersector indices organized by Nsum}
  // Read in lsu3shell unit tensors
  // transform block for each unit tensor to spncci
  // identify unit tensors with non-zero rmes's between each lgi pair 
  // Generate unit tensor labels for recurrence for each lgi pair
  // put seed blocks into hypersector blocks for each lgi pair 



  // Get list of unit tensor labels between lgi's 
  std::vector<u3shell::RelativeUnitTensorLabelsU3ST> lgi_unit_tensor_labels;
  u3shell::GenerateRelativeUnitTensorLabelsU3ST(
    run_parameters.Nsigma0_ex_max, run_parameters.N1v,
    lgi_unit_tensor_labels,J0_for_unit_tensors,T0_for_unit_tensors,
    restrict_positive_N0
    );
  
  // // Index unit tensor space  
  // u3shell::RelativeUnitTensorSpaceU3S 
  //   lgi_unit_tensor_space(run_parameters.Nmax,run_parameters.N1v,lgi_unit_tensor_labels);
  
  // // generate baby spncci hypersectors 
  // spncci::BabySpNCCIHypersectors 
  //   lgi_baby_spncci_hypersectors(baby_spncci_space, lgi_unit_tensor_space);


  ////////////////////////////////////////////////////////////////
  // read lsu3shell seed unit tensor rmes
  ////////////////////////////////////////////////////////////////
  // timing start
  Timer timer_read_seeds;
  timer_read_seeds.Start();

  std::cout << "Get seed unit tensor rmes..." << std::endl;

  // diagnostic
  std::cout << fmt::format("  seed unit tensors {}",lgi_unit_tensor_labels.size()) << std::endl;
  
  // set up non_zero hypersector indexing
  // and resize each of the OperatorBlocks in the Hyperblocks
  // basis::OperatorHyperblocks<double> lgi_hyperblocks(lgi_baby_spncci_hypersectors.size());
  // for(int i=0; i<lgi_baby_spncci_hypersectors.size(); ++i)
  //   lgi_hyperblocks[i].resize(lgi_baby_spncci_hypersectors.GetHypersector(i).size());

  // std::set<int> lgi_nonzero_hypersectors;

  // for each unit tensor, read in unit tensor lsu3shell rmes and transform to spncci basis
  // Store each unit tensor block in appropriate hyperblock

  // Container for lgi unit tensor blocks 
  std::map< std::pair<int,int>, std::map<std::pair<int,int>, basis::OperatorBlocks<double>>> lgi_unit_tensor_blocks;
  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  for (int unit_tensor_index=0; unit_tensor_index<lgi_unit_tensor_labels.size(); ++unit_tensor_index)
    {
      const u3shell::RelativeUnitTensorLabelsU3ST& unit_tensor_labels = lgi_unit_tensor_labels[unit_tensor_index];

      // get hypersector index 
      u3::SU3 x0; 
      HalfInt S0,T0,Sp,Tp,S,T;
      int etap,eta;
      std::tie(x0,S0,T0,etap,Sp,Tp,eta,S,T)=unit_tensor_labels.FlatKey();

      u3shell::UnitTensorSubspaceLabels unit_tensor_subspace_labels(x0,S0,etap,eta);
      int unit_tensor_subspace_index=unit_tensor_space.LookUpSubspaceIndex(unit_tensor_subspace_labels);

      auto& subspace=unit_tensor_space.GetSubspace(unit_tensor_subspace_index);
      int unit_tensor_state_index=subspace.LookUpStateIndex(std::tuple<int,int,int,int,int>(int(T0), int(Sp),int(Tp),int(S),int(T)));

      // basis::MatrixVector lgi_unit_tensor_lsu3shell_matrices;
      u3shell::SectorsU3SPN unit_tensor_sectors;
      std::string filename = fmt::format(run_parameters.relative_unit_tensor_filename_template,unit_tensor_index);
      basis::MatrixVector unit_tensor_spncci_matrices;

      // was a function      
      // generate sector labels 
      const bool spin_scalar = false;
      unit_tensor_sectors = u3shell::SectorsU3SPN(lsu3shell_space,unit_tensor_labels,spin_scalar);
      
      // read in lsu3shell rms for unit tensor 
      basis::MatrixVector unit_tensor_lsu3shell_matrices;
      lsu3shell::ReadLSU3ShellRMEs(
          filename,
          lsu3shell_basis_table,lsu3shell_space,
          unit_tensor_labels,unit_tensor_sectors,unit_tensor_lsu3shell_matrices
        );

      // transform seed rmes to SpNCCI basis (among LGIs)
      lgi::TransformOperatorToSpBasis(
          unit_tensor_sectors,lgi_expansions,
          unit_tensor_lsu3shell_matrices,unit_tensor_spncci_matrices
        );

      // map seed blocks into lgi hyperblocks
      for(int sector_index=0; sector_index<unit_tensor_sectors.size(); ++sector_index)
          {

            if(mcutils::IsZero(unit_tensor_spncci_matrices[sector_index],spncci::g_zero_tolerance))
              continue;
            
            // extract U3SPN sector information
            const typename u3shell::SectorsU3SPN::SectorType& sector = unit_tensor_sectors.GetSector(sector_index);
            const int bra_subspace_index = sector.bra_subspace_index();
            const int ket_subspace_index = sector.ket_subspace_index();
            const u3shell::SubspaceU3SPN bra_subspace=sector.bra_subspace();
            const u3shell::SubspaceU3SPN ket_subspace=sector.ket_subspace();
            const u3::U3& bra_sigma = bra_subspace.U3();
            const u3::U3& ket_sigma = ket_subspace.U3();

            const int rho0 = unit_tensor_sectors.GetSector(sector_index).multiplicity_index();

            // Get baby spncci index 
            spncci::BabySpNCCISubspaceLabels 
              baby_spncci_bra(bra_sigma,bra_subspace.Sp(),bra_subspace.Sn(), bra_subspace.S(),bra_sigma);
            spncci::BabySpNCCISubspaceLabels 
              baby_spncci_ket(ket_sigma,ket_subspace.Sp(),ket_subspace.Sn(), ket_subspace.S(), ket_sigma);

            int baby_spncci_index_bra=baby_spncci_space.LookUpSubspaceIndex(baby_spncci_bra);
            int baby_spncci_index_ket=baby_spncci_space.LookUpSubspaceIndex(baby_spncci_ket);


            int irrep_family_index_bra=baby_spncci_space.GetSubspace(baby_spncci_index_bra).irrep_family_index();
            int irrep_family_index_ket=baby_spncci_space.GetSubspace(baby_spncci_index_ket).irrep_family_index();
            std::pair<int,int> irrep_family_pair(irrep_family_index_bra,irrep_family_index_ket);
            auto& subspace_blocks=lgi_unit_tensor_blocks[irrep_family_pair];
            
            // If not already in map, need to resize unit tensor block container for given unit tensor subspace
            std::pair<int,int> multiplicity_tagged_unit_tensor_subspace(unit_tensor_subspace_index,rho0);
            if(not subspace_blocks.count(multiplicity_tagged_unit_tensor_subspace))
              subspace_blocks[multiplicity_tagged_unit_tensor_subspace].resize(unit_tensor_space.GetSubspace(unit_tensor_subspace_index).size());

            // Store block
            // if(rho0==2)
            // if(irrep_family_index_ket==4)
            //   std::cout<<irrep_family_index_bra<<std::endl<<std::endl;
            subspace_blocks[multiplicity_tagged_unit_tensor_subspace][unit_tensor_state_index]=unit_tensor_spncci_matrices[sector_index];
           }
    }

  timer_read_seeds.Stop();
  std::cout << fmt::format("(Task time: {})",timer_read_seeds.ElapsedTime()) << std::endl;

  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  //create a map of vectors of unit tensor subspace indices keyed by spncci irrep pairs 
  std::map<std::pair<int,int>,std::set<int>>lgi_unit_tensor_subset;
  for(auto it=lgi_unit_tensor_blocks.begin(); it!=lgi_unit_tensor_blocks.end(); ++it)
    for(auto it2=it->second.begin(); it2!=it->second.end(); ++it2)
      lgi_unit_tensor_subset[it->first].insert(it2->first.first);
  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // for each lgi pair
  for(auto it=lgi_unit_tensor_blocks.begin(); it!=lgi_unit_tensor_blocks.end(); ++it)
    {
      int irrep_family_index_bra,irrep_family_index_ket;
      std::tie(irrep_family_index_bra,irrep_family_index_ket)=it->first;

      if(irrep_family_index_bra!=0 || irrep_family_index_ket!=0)
        continue;
      // get seeds for given lgi pair
      auto& seed_blocks=it->second;  

      // Get operator subset labels     
      const std::set<int>& lgi_unit_tensors=lgi_unit_tensor_subset[it->first];

      // Only include N0=0 sectors if bra less than ket so no duplicates
      bool include_zero=(irrep_family_index_bra<=irrep_family_index_ket);

      // std::cout<<"bool "<<include_zero<<std::endl;
      // Get full set of unit tensor subspaces for recurrence
      std::map<spncci::NnPair,std::set<int>> unit_tensor_subsets;
      spncci::GenerateRecurrenceUnitTensors(
        run_parameters.Nmax,lgi_unit_tensors,unit_tensor_space,
        unit_tensor_subsets,include_zero
        );


      std::cout<<"checking the recurrence unit tensors "<<std::endl;

      // generate baby spncci hypersectors for given irrep family from unit tensor subspace
      std::vector<std::vector<int>> unit_tensor_hypersector_subsets(2*run_parameters.Nmax);
      spncci::BabySpNCCIHypersectors 
        baby_spncci_hypersectors(
          baby_spncci_space, unit_tensor_space, 
          unit_tensor_subsets, unit_tensor_hypersector_subsets,
          irrep_family_index_bra, irrep_family_index_ket
        );

      // std::cout<<"checking hypersector subsets"<<std::endl;
      // for(int N=0; N<unit_tensor_hypersector_subsets.size(); N++)
      //   std::cout<<unit_tensor_hypersector_subsets[N].size()<<std::endl;

      // zero initialize hypersectors 
      basis::OperatorHyperblocks<double> unit_tensor_hyperblocks;
      basis::SetHyperoperatorToZero(baby_spncci_hypersectors,unit_tensor_hyperblocks);

      basis::OperatorHyperblocks<double> unit_tensor_hyperblocks_explicit;
      basis::SetHyperoperatorToZero(baby_spncci_hypersectors,unit_tensor_hyperblocks_explicit);

      
      // for(int i=0; i<unit_tensor_hyperblocks.size(); ++i)
      //   for(int j=0; j<unit_tensor_hyperblocks[i].size(); ++j)
      //     {
      //       auto& hypersector=baby_spncci_hypersectors.GetHypersector(i);
      //       int bra, ket, tensor, rho0;
      //       std::tie(bra,ket,tensor,rho0)=hypersector.Key();
      //       auto& bra_subspace=baby_spncci_space.GetSubspace(bra);
      //       auto& ket_subspace=baby_spncci_space.GetSubspace(ket);
      //       const Eigen::MatrixXd matrix1=unit_tensor_hyperblocks[i][j];
      //       const Eigen::MatrixXd matrix2=unit_tensor_hyperblocks_explicit[i][j];
      //       // std::cout<<"hyperblock "<<i<<std::endl;
      //       // std::cout<<matrix1-matrix2<<std::endl;
      //       // if(not mcutils::IsZero(matrix1-matrix2, spncci::g_zero_tolerance))
      //         {
      //           // std::cout<<"hyperblock "<<i<<" sub-block "<<j<<" is not correct"<<std::endl;
      //           std::cout<<"the matrix should be "<<bra_subspace.size()<<" x "<<ket_subspace.size()<<std::endl;
      //           std::cout<<"gammma_max: "<<ket_subspace.gamma_max()<<" upsilon_max "<<ket_subspace.upsilon_max()<<std::endl;
      //           std::cout<<"matrix1"<<std::endl<<matrix1<<std::endl<<"matrix2"
      //           <<std::endl<<matrix2<<std::endl;
      //         }
 
      //     }


      // Populate hypersectors with seeds
      for(int hypersector_index : unit_tensor_hypersector_subsets[0])
        {
          const auto& hypersector
            =baby_spncci_hypersectors.GetHypersector(hypersector_index);
          int unit_tensor_subspace_index=hypersector.operator_subspace_index();
          int rho0=hypersector.multiplicity_index();
          const basis::OperatorBlocks<double>& seeds=seed_blocks[std::pair<int,int>(unit_tensor_subspace_index,rho0)];
          for(int i=0; i<seeds.size(); ++i)
            {
              if(seeds[i].rows()==0)
                continue;
              
              unit_tensor_hyperblocks[hypersector_index][i]=seeds[i];
            }
        }



      std::cout<<"lgi pair "<<irrep_family_index_bra<<"  "<<irrep_family_index_ket<<std::endl;
      std::cout<<"checking seed hypersectors"<<std::endl;
      for(int hypersector_index : unit_tensor_hypersector_subsets[0])
        {
          const auto& hypersector
            =baby_spncci_hypersectors.GetHypersector(hypersector_index);
          
          int unit_tensor_subspace_index, ket_subspace_index,bra_subspace_index, rho0;
          std::tie(bra_subspace_index, ket_subspace_index,unit_tensor_subspace_index,rho0)=hypersector.Key();
  
          const auto& unit_tensor_subspace=unit_tensor_space.GetSubspace(unit_tensor_subspace_index);
          const auto& bra_subspace=baby_spncci_space.GetSubspace(bra_subspace_index);
          const auto& ket_subspace=baby_spncci_space.GetSubspace(ket_subspace_index);

          // std::cout<<"hypersector "<<hypersector_index<<" "<< bra_subspace.LabelStr()<<"  "<<ket_subspace.LabelStr()
          // <<unit_tensor_subspace.LabelStr()<<rho0<<std::endl;
          // for(int i=0; i<unit_tensor_subspace.size(); ++i)
          //   std::cout<<unit_tensor_hyperblocks[hypersector_index][i]<<std::endl<<std::endl;
        }

      // Recurse over unit tensor hyper sectors 
      std::cout<<"entering the recurrence for "<<irrep_family_index_bra<<" "<<irrep_family_index_ket<<std::endl;
      spncci::ComputeUnitTensorHyperblocks(
        run_parameters.Nmax,u_coef_cache,phi_coef_cache,k_matrix_cache,
        spncci_space,baby_spncci_space,unit_tensor_space,
        baby_spncci_hypersectors, unit_tensor_hypersector_subsets,
        unit_tensor_hyperblocks
        );



      ////////////////////////////////////////////////////////////////////////////////////////////////////////////
      // Checking unit tensors
      ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      
      const u3::U3& sigmap=spncci_space[irrep_family_index_bra].sigma();
      const u3::U3& sigma =spncci_space[irrep_family_index_ket].sigma();
  
      // basis::OperatorHyperblocks<double> unit_tensor_hyperblocks_explicit;
      // basis::SetHyperoperatorToZero(baby_spncci_hypersectors,unit_tensor_hyperblocks_explicit);
      for (int unit_tensor_index=0; unit_tensor_index<lgi_unit_tensor_labels.size(); ++unit_tensor_index)
        {
          const u3shell::RelativeUnitTensorLabelsU3ST& unit_tensor = lgi_unit_tensor_labels[unit_tensor_index];

          // get hypersector index 
          u3::SU3 x0; 
          HalfInt S0,T0,Sp,Tp,S,T;
          int etap,eta;
          std::tie(x0,S0,T0,etap,Sp,Tp,eta,S,T)=unit_tensor.FlatKey();

          u3shell::UnitTensorSubspaceLabels unit_tensor_subspace_labels(x0,S0,etap,eta);
          int unit_tensor_subspace_index=unit_tensor_space.LookUpSubspaceIndex(unit_tensor_subspace_labels);

          auto& subspace=unit_tensor_space.GetSubspace(unit_tensor_subspace_index);
          int unit_tensor_state_index
            =subspace.LookUpStateIndex(std::tuple<int,int,int,int,int>(int(T0), int(Sp),int(Tp),int(S),int(T)));

          const bool spin_scalar = false;
          u3shell::SectorsU3SPN unit_tensor_sectors;
          unit_tensor_sectors = u3shell::SectorsU3SPN(lsu3shell_space,unit_tensor,spin_scalar);
          
          // read in lsu3shell rms for unit tensor 
          basis::MatrixVector unit_tensor_lsu3shell_blocks;
          std::string filename = fmt::format(run_parameters.relative_unit_tensor_filename_template,unit_tensor_index);
          lsu3shell::ReadLSU3ShellRMEs(
              filename,
              lsu3shell_basis_table,lsu3shell_space,
              unit_tensor,unit_tensor_sectors,unit_tensor_lsu3shell_blocks
            );

          spncci::ComputeUnitTensorSectorsExplicit(
            sigmap, sigma, unit_tensor,unit_tensor_space,
            lsu3shell_space,unit_tensor_sectors,unit_tensor_lsu3shell_blocks,
            baby_spncci_space, spncci_expansions,baby_spncci_hypersectors,
            unit_tensor_hyperblocks_explicit
          );
        }
      for(int i=0; i<unit_tensor_hyperblocks.size(); ++i)
        for(int j=0; j<unit_tensor_hyperblocks[i].size(); ++j)
          {
            auto& hypersector=baby_spncci_hypersectors.GetHypersector(i);
            int bra, ket, tensor, rho0;
            std::tie(bra,ket,tensor,rho0)=hypersector.Key();
            auto& bra_subspace=baby_spncci_space.GetSubspace(bra);
            auto& ket_subspace=baby_spncci_space.GetSubspace(ket);
            auto& tensor_subspace=unit_tensor_space.GetSubspace(tensor);
            const Eigen::MatrixXd matrix1=unit_tensor_hyperblocks[i][j];
            const Eigen::MatrixXd matrix2=unit_tensor_hyperblocks_explicit[i][j];
            // std::cout<<"hyperblock "<<i<<std::endl;
            // std::cout<<matrix1-matrix2<<std::endl;
            if(not mcutils::IsZero(matrix1-matrix2, 1e-4))
              {
                std::cout<<"hyperblock "<<i<<" sub-block "<<j<<" is not correct"<<std::endl;
                std::cout<<bra_subspace.LabelStr()<<"  "<<ket_subspace.LabelStr()<<"  "<<tensor_subspace.LabelStr()<<"  "
                << rho0<<std::endl;
                std::cout<<"the matrix should be "<<bra_subspace.size()<<" x "<<ket_subspace.size()<<std::endl;
                std::cout<<"gammma_max: "<<ket_subspace.gamma_max()<<" upsilon_max "<<ket_subspace.upsilon_max()<<std::endl;
                std::cout<<"matrix1"<<std::endl<<matrix1<<std::endl<<"matrix2"
                <<std::endl<<matrix2<<std::endl;
              }
          }
      
    }// end lgi_pair
}
