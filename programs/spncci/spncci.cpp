/****************************************************************
  spncci.cpp

  Tests of explicit SpNCCI basis construction in LSU3Shell basis.

  This code just tests normalization, but using clean refactored
  infrastructure.  Other deeper tests (of unit tensor matrix elements)
  were carried out in compute_unit_tensor_rmes.cpp.

  Required data:

  * Relative operator lsu3shell rme input files are generated by

      generate_lsu3shell_relative_operators.cpp

    which is invoked through scripting in

      compute_relative_tensors_lsu3shell_rmes.py

    Example: Z=3 N=3 twice_Nsigma0=22 Nmax=2 Nstep=2 N1v[=N1b]=1
   
    % python3 script/compute_relative_tensors_lsu3shell_rmes.py 3 3 22 2 2 1

    Only need .rme and .dat files.

    Not saved to repository since ~3.5 Mb...

       data/lsu3shell/lsu3shell_rme_6Li_Nmax02
    
  * Relative Hamiltonian (and observable) upcoupled rme files are
    generated by

      generate_relative_u3st_operators

    which is invoked manually for now as

      generate_relative_u3st_operators A Nmax N1v basename

   Example:

       ../operators/generate_relative_u3st_operators 6 2 1 hamiltonian

       with hamiltonian.load containing

       20    // hw
       Tintr 1.0    // coef
       INT 1.0 4 0 0 0 relative_observables/JISP16_Nmax20_hw20.0_rel.dat      // coef Jmax J0 T0 g0 interaction_filename

       ../operators/generate_relative_u3st_operators 6 2 1 Nintr

       with Nintr.load containing

       20    // hw
       Nintr 1.0    // coef

       ../operators/generate_relative_u3st_operators 6 2 1 r2intr

       with r2intr.load containing

       20    // hw
       r2intr 1.0    // coef

   % ln -s ../../data/relative_observables/

         
     

  Anna E. McCoy and Mark A. Caprio
  University of Notre Dame

  2/20/17 (mac): Created (starting from explicit.cpp).
****************************************************************/

#include <cstdio>
#include <ctime>
#include <fstream>
#include <sys/resource.h>

#include "SymEigsSolver.h"  // from spectra

#include "cppformat/format.h"
#include "mcutils/parsing.h"
#include "lgi/lgi_solver.h"
#include "mcutils/profiling.h"
#include "spncci/computation_control.h"
#include "spncci/explicit_construction.h"
#include "spncci/io_control.h"

// to vett as moved into computation_control 
#include "mcutils/eigen.h"

////////////////////////////////////////////////////////////////
// WIP code
//
// to extract to spncci library when ready
////////////////////////////////////////////////////////////////
  
namespace spncci
{
  
  void
  GenerateRecurrenceUnitTensors(
      int Nmax,
      const u3shell::RelativeUnitTensorSpaceU3S& lgi_unit_tensor_space, 
      const std::set<int>& lgi_operator_space_subset,
      const u3shell::RelativeUnitTensorSpaceU3S& unit_tensor_space,
      std::map<spncci::NnPair,std::set<int>>& operator_subsets,
      std::map<int,int>& seed_unit_tensor_lookup_table
    )
  // for a single irrep pair
  // TODO verify that we have correct conj sectors for Nn=0
  {
    u3::SU3 x0; 
    HalfInt S0;
    int etap,eta;

    // fill in operator_space_subsets with lgi information 
    // need to map lgi_unit_tensor_space indices to unit_tensor_space
    std::set<int> operator_subset=operator_subsets[spncci::NnPair(0,0)];
    for(int lgi_operator_subspace_index : lgi_operator_space_subset)
      {
        auto lgi_unit_tensor_subspace_labels
          =lgi_unit_tensor_space.GetSubspace(lgi_operator_subspace_index).labels();
        int unit_tensor_subspace_index=unit_tensor_space.LookUpSubspaceIndex(lgi_unit_tensor_subspace_labels);
        operator_subset.insert(unit_tensor_subspace_index);
        seed_unit_tensor_lookup_table[unit_tensor_subspace_index]=lgi_operator_subspace_index;
      }

    // Generate non-lgi unit tensor family labels 
    for(int Nsum=0; Nsum<=2*Nmax; Nsum+=2)
      for(int Nn=0; Nn<=std::min(Nsum,Nmax); Nn+=2)
        {
          int Nnp=Nsum-Nn;
          if((Nnp<0)||(Nnp>Nmax))
            continue;

          const std::set<int>& source_operator_subspace_indices=operator_subsets[spncci::NnPair(Nnp,Nn)];

          spncci::NnPair NnpNn2(Nnp,Nn+2);
          for(int source_operator_subspace_index : source_operator_subspace_indices)
            {
              std::tie(x0,S0,etap,eta)=unit_tensor_space.GetSubspace(source_operator_subspace_index).labels();
              MultiplicityTagged<u3::SU3>::vector x0p_set1=KroneckerProduct(u3::SU3(etap-2,0), u3::SU3(0,eta));
              for(auto& x0p_tagged : x0p_set1)
                {
                  u3::SU3 x0p(x0p_tagged.irrep);
                  u3shell::UnitTensorSubspaceLabels unit_tensor_subspace_labels(x0p,S0,etap-2,eta);
                  int operator_subspace_index=unit_tensor_space.LookUpSubspaceIndex(unit_tensor_subspace_labels);
                  operator_subsets[NnpNn2].insert(operator_subspace_index);

                }

              MultiplicityTagged<u3::SU3>::vector x0p_set2=KroneckerProduct(u3::SU3(etap,0), u3::SU3(0,eta+2)); 
              for(auto& x0p_tagged : x0p_set2)
                {
                  u3::SU3 x0p(x0p_tagged.irrep);
                  u3shell::UnitTensorSubspaceLabels unit_tensor_subspace_labels(x0p,S0,etap,eta+2);
                  int operator_subspace_index=unit_tensor_space.LookUpSubspaceIndex(unit_tensor_subspace_labels);
                  operator_subsets[NnpNn2].insert(operator_subspace_index);
                }

              operator_subsets[spncci::NnPair(Nnp+2,Nn+2)].insert(source_operator_subspace_index);
            }
        }
  }


  void
  WriteEigenValues(
    const std::vector<HalfInt>& J_values, double hw, 
    int Nmax, int Nsigma0_ex_max,
    std::map<HalfInt,Eigen::VectorXd>& eigenvalues,
    std::vector<std::string>& observable_filenames,
    std::vector<int>& scalar_observable_indices,
    std::vector<std::map<HalfInt,Eigen::VectorXd>>& scalar_observable_expectations,
    std::vector<int>& nonscalar_observable_indices,
    std::vector<std::map<spncci::JPair,Eigen::MatrixXd>>& nonscalar_observable_expectations
  )
  // for observables with J0=0, line them up with energy eigenvalue and read off diagonal matrix elements 
  // for observables with J0!=0, then have their own section --probably do this in the code as well, i.e.,
  {
    std::string filename=fmt::format("eigenvalues_Nmax{:02d}_Nsigma_ex{:02d}.dat",Nmax,Nsigma0_ex_max);
    std::cout<<"writing to file"<<std::endl;
    std::fstream fs;
    const int width=3;
    const int precision=16;
    fs.open (filename, std::fstream::out | std::fstream::app);
    fs << std::setprecision(precision);

    fs << "OUPTPUT from spncci Version 1"<<std::endl<<std::endl;;
    fs << "Scalar observables:";
    for(int i=0; i<scalar_observable_indices.size(); ++i)
      fs <<"  "<<observable_filenames[scalar_observable_indices[i]];
    fs << std::endl;

    fs <<"Nonscalar observables:";
    for(int i=0; i<nonscalar_observable_indices.size(); ++i)
      fs <<"  "<<observable_filenames[nonscalar_observable_indices[i]];

    fs << std::endl<<fmt::format("hw {:2.1f}", hw)<<std::endl;

    for(HalfInt J : J_values)
      {
        Eigen::VectorXd& eigenvalues_J=eigenvalues[J];
        // Eigen::VectorXd& observables=observable_expectations[J];

        for(int i=0; i<eigenvalues_J.size(); ++i)
          {
            double eigenvalue=eigenvalues_J(i);
            std::cout<<fmt::format("{:2d}   {}   {:8.5f}",i, J,eigenvalue);
            fs << fmt::format("{:2d}   {}   {:8.5f}",i, J,eigenvalue);
            
            for(int j=0; j<scalar_observable_indices.size(); ++j)  
            {          
              std::cout<<fmt::format("   {:8.5f}",scalar_observable_expectations[j][J](i))
              <<std::endl<<std::endl;
              fs <<fmt::format("   {:8.5f}",scalar_observable_expectations[j][J](i))
              <<std::endl<<std::endl;
            }
          }
      }
    for(HalfInt J : J_values)
      {
        Eigen::VectorXd& eigenvalues_J_initial=eigenvalues[J];
        for(int i=0; i<eigenvalues_J_initial.size(); ++i)
          for(HalfInt Jp :J_values)
          {
            Eigen::VectorXd& eigenvalues_J_final=eigenvalues[Jp];
            spncci::JPair J_pair(Jp,J);
            for(int ip=0; ip<eigenvalues_J_final.size(); ++ip)
              {
                double eigenvalue_initial=eigenvalues_J_initial(i);
                double eigenvalue_final=eigenvalues_J_final(ip);
                fs << fmt::format("{:2d}   {}   {:2d}   {}   {:8.5f}   {:8.5f}",
                      i,J,ip,Jp,eigenvalue_initial,eigenvalue_final);

                for(int j=0; j<nonscalar_observable_indices.size(); ++j)
                  {
                    // std::cout<<"(ip, i) ("<<ip<<","<<i<<")"<<std::endl;
                    Eigen::MatrixXd& obserable_matrix=nonscalar_observable_expectations[j][J_pair];
                    // std::cout<<obserable_matrix<<std::endl;
                    double observable=obserable_matrix(ip,i);
                    fs<<fmt::format("  {:8.5f}",observable);
                  }
                fs<<std::endl;
              }
          }
      }
    fs<<std::endl<<std::endl;
    fs.close();
  }

}// end namespace

////////////////////////////////////////////////////////////////
// run parameters
////////////////////////////////////////////////////////////////

struct RunParameters
// Structure to store input parameters for run.
//
// Data members:
//   A (int): Atomic mass.
//   ...
{

  // constructor
  RunParameters(int argc, char **argv); 

  // basis parameters
  int A;
  HalfInt Nsigma_0;
  int Nsigma0_ex_max;
  int N1v;
  int Nmax;

  // filenames
  std::string lsu3shell_rme_directory;
  std::string lsu3shell_basis_filename;
  std::string Brel_filename;
  std::string Arel_filename;
  std::string Nrel_filename;
  std::string relative_unit_tensor_filename_template;

  // many-body problem
  std::string observable_directory;
  std::vector<std::string> observable_filenames;  // first observable is used as Hamiltonian
  std::vector<int> observable_Jvalues;
  int num_observables;
  std::vector<HalfInt> J_values;
  std::vector<double> hw_values;

  // eigensolver
  int num_eigenvalues;
  int eigensolver_num_convergence;  // whatever exactly this is...
  int eigensolver_max_iterations;
  double eigensolver_tolerance;

};

RunParameters::RunParameters(int argc, char **argv)
{
  // read from command line arguments
  //
  // TODO reorder filenames 
  if (argc<5)
    {
      std::cout << "Syntax: A twice_Nsigma0 Nsigma0_ex_max N1v Nmax num_eigenvalues <load file>"
       // <basis filename> <Nrel filename> <Brel filename> <Arel filename>" 
                << std::endl;
      std::exit(1);
    }
  A = std::stoi(argv[1]); 
  int twice_Nsigma0= std::stoi(argv[2]);
  Nsigma0_ex_max=std::stoi(argv[3]);
  Nsigma_0=HalfInt(twice_Nsigma0,2);
  N1v=std::stoi(argv[4]);
  Nmax = std::stoi(argv[5]);
  num_eigenvalues=std::stoi(argv[6]);
  std::string load_file=argv[7];

  // std::cout<< fmt::format("{} {} {} {} {} {}",A, twice_Nsigma0, Nsigma_0, Nsigma0_ex_max, N1v, Nmax)<<std::endl;
  
  // many-body problem
  // observable_filenames = std::vector<std::string>({"hamiltonian_u3st.dat"});

  // Reading in from load life 
  int line_count=0;
  int twice_Jmin, twice_Jmax, J_step;
  double hw_min, hw_max, hw_step;
  std::string line, observable;
  std::ifstream is(fmt::format("{}.load",load_file));
  
  assert(is);
  int J0;
  while(std::getline(is,line))
    {
      std::istringstream line_stream(line);
      ++line_count;
      if(line_count==1)
      {
        line_stream >> twice_Jmin >> twice_Jmax >> J_step;
        ParsingCheck(line_stream,line_count,line);
      }
      else if(line_count==2)
      {
        line_stream >> hw_min >> hw_max >> hw_step;
        ParsingCheck(line_stream,line_count,line);
      }
      else
      {
        line_stream >> observable >> J0;
        ParsingCheck(line_stream,line_count,line);
        observable_filenames.push_back(observable);
        observable_Jvalues.push_back(J0);
      }
    }

  num_observables = observable_filenames.size();
  observable_directory="relative_observables";
  // generate list of J values 
  HalfInt Jmin(twice_Jmin,2);
  HalfInt Jmax(twice_Jmax,2);
  for(HalfInt J=Jmin; J<=Jmax; J+=J_step)
    J_values.push_back(J);

  std::cout<<"J values are: ";
  for(auto J : J_values)
    std::cout<<J<<"  ";
  std::cout<<std::endl;

  for(double hw=hw_min; hw<=hw_max; hw+=hw_step)
    hw_values.push_back(hw);

  std::cout<<"hw values are: ";
  for(auto hw : hw_values)
    std::cout<<hw<<"  ";
  std::cout<<std::endl;


  // hard-coded directory structure and filenames
  lsu3shell_rme_directory = "lsu3shell_rme";
  lsu3shell_basis_filename = lsu3shell_rme_directory + "/" + "lsu3shell_basis.dat";
  Brel_filename = lsu3shell_rme_directory + "/" + fmt::format("Brel_06_Nmax{:02d}.rme",Nsigma0_ex_max);
  Arel_filename = lsu3shell_rme_directory + "/" + fmt::format("Arel_06_Nmax{:02d}.rme",Nsigma0_ex_max);
  Nrel_filename = lsu3shell_rme_directory + "/" + fmt::format("Nrel_06_Nmax{:02d}.rme",Nsigma0_ex_max);
  relative_unit_tensor_filename_template = lsu3shell_rme_directory + "/" + "relative_unit_{:06d}.rme";

  // hard-coded eigen solver parameters   
  eigensolver_num_convergence = 2*num_eigenvalues;    // docs for SymEigsSolver say to take "ncv>=2*nev"
  eigensolver_max_iterations = 100*num_eigenvalues;
  eigensolver_tolerance = 1e-8;
}


////////////////////////////////////////////////////////////////
// main body
////////////////////////////////////////////////////////////////

int main(int argc, char **argv)
{
  std::cout<<"entering spncci"<<std::endl;
  ////////////////////////////////////////////////////////////////
  // initialization
  ////////////////////////////////////////////////////////////////
  
  // SU(3) caching
  u3::U3CoefInit();
  u3::UCoefCache u_coef_cache;
  u3::PhiCoefCache phi_coef_cache;
  u3::g_u_cache_enabled = true;

  // numerical parameter for certain calculations
  double zero_threshold=1e-8;  // DEPRECATED but still may be used some places
  spncci::g_zero_tolerance = 1e-6;
  spncci::g_suppress_zero_sectors = true;

  // run parameters
  RunParameters run_parameters(argc,argv);

  // Eigen OpenMP multithreading mode
  Eigen::initParallel();
  // Eigen::setNbThreads(0);

  ////////////////////////////////////////////////////////////////
  // read lsu3shell basis
  ////////////////////////////////////////////////////////////////

  std::cout << "Read lsu3shell basis..." << std::endl;

  // read lsu3shell basis (regroup into U3SPN subspaces)
  lsu3shell::LSU3BasisTable lsu3shell_basis_table;
  lsu3shell::U3SPNBasisLSU3Labels lsu3shell_basis_provenance;
  u3shell::SpaceU3SPN lsu3shell_space;
  lsu3shell::ReadLSU3Basis(
      run_parameters.Nsigma_0,run_parameters.lsu3shell_basis_filename,
      lsu3shell_basis_table,lsu3shell_basis_provenance,lsu3shell_space
    );

  ////////////////////////////////////////////////////////////////
  // solve for LGIs
  ////////////////////////////////////////////////////////////////
  std::cout << "Solve for LGIs..." << std::endl;

  // timing start
  Timer timer_lgi;
  timer_lgi.Start();

  u3shell::SectorsU3SPN Brel_sectors, Arel_sectors, Nrel_sectors;
  basis::MatrixVector Brel_matrices, Arel_matrices, Nrel_matrices;
  spncci::ReadLSU3ShellSymplecticOperatorRMEs(
      lsu3shell_basis_table,lsu3shell_space, 
      run_parameters.Brel_filename,Brel_sectors,Brel_matrices,
      run_parameters.Arel_filename,Arel_sectors,Arel_matrices,
      run_parameters.Nrel_filename,Nrel_sectors,Nrel_matrices
    );

  const u3shell::SectorsU3SPN& Ncm_sectors = Nrel_sectors;
  basis::MatrixVector Ncm_matrices;
  lsu3shell::GenerateLSU3ShellNcmRMEs(
      lsu3shell_space,Nrel_sectors,Nrel_matrices,
      run_parameters.A,
      Ncm_matrices
    );

  lgi::MultiplicityTaggedLGIVector lgi_families;
  basis::MatrixVector lgi_expansions;
  // bool keep_zero_sectors=true;
  lgi::GenerateLGIExpansion(
      lsu3shell_space, 
      Brel_sectors,Brel_matrices,Ncm_sectors,Ncm_matrices,
      run_parameters.Nsigma_0,
      lgi_families,lgi_expansions
      // keep_zero_sectors
    );

  // diagnostics
  std::cout << fmt::format("  LGI families {}",lgi_families.size()) << std::endl;
  if (false)
    lgi::WriteLGILabels(lgi_families,std::cout);

  // timing stop
  timer_lgi.Stop();
  std::cout << fmt::format("(Task time: {})",timer_lgi.ElapsedTime()) << std::endl;

  ////////////////////////////////////////////////////////////////
  // set up SpNCCI space
  ////////////////////////////////////////////////////////////////

  std::cout << "Set up SpNCCI space..." << std::endl;

  // build SpNCCI irrep branchings
  spncci::SpNCCISpace spncci_space;
  spncci::SigmaIrrepMap sigma_irrep_map;  // persistent container to store branchings
  spncci::NmaxTruncator truncator(run_parameters.Nsigma_0,run_parameters.Nmax);
  spncci::GenerateSpNCCISpace(lgi_families,truncator,spncci_space,sigma_irrep_map);

  // diagnostics
  std::cout << fmt::format("  Irrep families {}",spncci_space.size()) << std::endl;
  std::cout << fmt::format("  TotalU3Subspaces {}",spncci::TotalU3Subspaces(spncci_space)) << std::endl;
  std::cout << fmt::format("  TotalDimensionU3 {}",spncci::TotalDimensionU3S(spncci_space)) << std::endl;

  ////////////////////////////////////////////////////////////////
  // precompute K matrices
  ////////////////////////////////////////////////////////////////

  std::cout << "Precompute K matrices..." << std::endl;

  // timing start
  Timer timer_k_matrices;
  timer_k_matrices.Start();

  // traverse distinct sigma values in SpNCCI space, generating K
  // matrices for each
  spncci::KMatrixCache k_matrix_cache;
  bool intrinsic = true;
  spncci::PrecomputeKMatrices(sigma_irrep_map,k_matrix_cache,intrinsic);

  // timing stop
  timer_k_matrices.Stop();
  std::cout << fmt::format("(Task time: {})",timer_k_matrices.ElapsedTime()) << std::endl;

  ///////////////////////////////////////////////////////////////////////////////////////////////////
  // Enumerate unit tensor space 
  ///////////////////////////////////////////////////////////////////////////////////////////////////
  // build baby spncci space 
  spncci::BabySpNCCISpace baby_spncci_space(spncci_space);

  int J0_for_unit_tensors = -1;  // all J0
  int T0_for_unit_tensors = -1;  // all T0
  const bool restrict_positive_N0 = false;  // don't restrict to N0 positive

  // get full set of possible unit tensor labels up to Nmax, N1v truncation
  std::vector<u3shell::RelativeUnitTensorLabelsU3ST> unit_tensor_labels;  
  u3shell::GenerateRelativeUnitTensorLabelsU3ST(
    run_parameters.Nmax, run_parameters.N1v,
    unit_tensor_labels,J0_for_unit_tensors,T0_for_unit_tensors,
    restrict_positive_N0
    );

  // generate unit tensor subspaces 
  u3shell::RelativeUnitTensorSpaceU3S 
    unit_tensor_space(run_parameters.Nmax,run_parameters.N1v,unit_tensor_labels);

  ///////////////////////////////////////////////////////////////////////////////////////////////////
  //  Read in observables  
  ///////////////////////////////////////////////////////////////////////////////////////////////////        
  std::cout << "Read observable relative rmes..." << std::endl;
  std::vector<std::vector<u3shell::RelativeRMEsU3SSubspaces>> observables_relative_rmes(run_parameters.num_observables);
  
  std::vector<std::vector<u3shell::IndexedOperatorLabelsU3S>> observable_symmetries_u3s; 
  // for each observable at the give hbar omega
  for (int observable_index=0; observable_index<run_parameters.num_observables; ++observable_index)
    {
      std::vector<u3shell::RelativeRMEsU3SSubspaces>&
         observable_relative_rmes=observables_relative_rmes[observable_index];
        
      observable_relative_rmes.resize(run_parameters.hw_values.size());      
      
      // temporary container 
      std::unordered_set<u3shell::IndexedOperatorLabelsU3S, boost::hash<u3shell::IndexedOperatorLabelsU3S>> symmetries_u3s;
      
      // for each value of hbar omega
      for(int h=0; h<run_parameters.hw_values.size(); ++h)
        {
          double hw=run_parameters.hw_values[h];

          std::string observable_filename=fmt::format("{}/{}_hw{:2.1f}_Nmax{:02d}_u3st.dat", 
              run_parameters.observable_directory,
              run_parameters.observable_filenames[observable_index],hw,run_parameters.Nmax);

          std::cout << fmt::format("  Reading {}...",observable_filename)<< std::endl;

          u3shell::RelativeRMEsU3SSubspaces& relative_rmes=observable_relative_rmes[h];
          u3shell::ReadRelativeOperatorU3ST(observable_filename,unit_tensor_space,relative_rmes);
          // turn into function
          for(auto it=relative_rmes.begin(); it!=relative_rmes.end(); ++it)
            {
              int unit_tensor_subspace_index, kappa0,L0,etap,eta;
              HalfInt S0;
              u3::SU3 x0;
              std::tie(unit_tensor_subspace_index,kappa0,L0)=it->first;
              std::tie(x0,S0,etap,eta)=unit_tensor_space.GetSubspace(unit_tensor_subspace_index).labels();
              symmetries_u3s.insert(u3shell::IndexedOperatorLabelsU3S(u3shell::OperatorLabelsU3S(etap-eta,x0,S0),kappa0,L0));
            }
        }
      for(auto tensor : symmetries_u3s)
        observable_symmetries_u3s[observable_index].push_back(tensor);
    }

  // set up U3S sectors for each of the observables 
  // Was the function ConstructObservablesU3S
  ///////////////////////////////////////////////////////////////////////////////////////////////
  // enumerate u3S space from baby spncci for each observable 
  spncci::SpaceU3S space_u3s(baby_spncci_space);

  // vector of sectors for each observable
  std::vector<std::vector<spncci::SectorLabelsU3S>> observables_sectors_u3s(run_parameters.num_observables);

  // vector of blocks for u3 sectors for each observable, for each hbar omega
  std::vector<std::vector<basis::OperatorBlocks<float>>> observables_blocks_u3s(run_parameters.num_observables);

  // for each observable, enumerate sectors 
  for(int observable_index=0; observable_index< run_parameters.num_observables; ++observable_index) 
    {
      std::vector<spncci::SectorLabelsU3S>& sectors_u3s=observables_sectors_u3s[observable_index];
      spncci::GetSectorsU3S(space_u3s,observable_symmetries_u3s[observable_index],sectors_u3s);
      std::vector<basis::OperatorBlocks<float>> observable_blocks_u3s=observables_blocks_u3s[observable_index];
      observable_blocks_u3s.resize(run_parameters.hw_values.size());
      
      // zero initialize each block
      for(int h=0; h<run_parameters.hw_values.size(); ++h)
        // based on SetOperatorToZero in basis library operator.h
        // will replace with template function when u3sectors converted to hypersectors 
        {
          basis::OperatorBlocks<float>& blocks=observable_blocks_u3s[h];
          for(int sector_index=0; sector_index<sectors_u3s.size(); ++sector_index)
            {
              int rows=space_u3s.GetSubspace(sectors_u3s[sector_index].bra_index()).sector_dim();
              int cols=space_u3s.GetSubspace(sectors_u3s[sector_index].ket_index()).sector_dim();
              blocks[sector_index]=basis::OperatorBlock<float>::Zero(rows,cols);
            }
        }

    } 
  ///////////////////////////////////////////////////////////////////////////////////////////////
  // Get list of unit tensor labels between lgi's 
  std::vector<u3shell::RelativeUnitTensorLabelsU3ST> lgi_unit_tensor_labels;
  u3shell::GenerateRelativeUnitTensorLabelsU3ST(
    run_parameters.Nsigma0_ex_max, run_parameters.N1v,
    lgi_unit_tensor_labels,J0_for_unit_tensors,T0_for_unit_tensors,
    restrict_positive_N0
    );
  
  // Generate list of unit tensor subspaces for different NnpNn sectors for each irrep family
  std::map<std::pair<int,int>,std::map<spncci::NnPair,std::set<int>>> unit_tensor_subsets_by_irrep_family;

  // Index unit tensor space  
  u3shell::RelativeUnitTensorSpaceU3S 
    lgi_unit_tensor_space(run_parameters.Nmax,run_parameters.N1v,lgi_unit_tensor_labels);
  
  // generate baby spncci hypersectors 
  spncci::BabySpNCCIHypersectors 
    lgi_baby_spncci_hypersectors(baby_spncci_space, lgi_unit_tensor_space);

  // create look up table relating lgi_unit_tensor_space and unit_tensor_space
  std::map<int,int> seed_unit_tensor_lookup_table;
  // Turn into function 
  {
    // generate unit tensor subspaces 
    // break up lgi unit tensors with symmetry sectors between state pairs in irrep family pair
    std::map<std::pair<int,int>, std::set<int>> lgi_unit_tensor_subsets;
    for(int hypersector_index=0; hypersector_index<lgi_baby_spncci_hypersectors.size(); ++hypersector_index)
      {
        auto& hypersector=lgi_baby_spncci_hypersectors.GetHypersector(hypersector_index);
        const auto& bra_subspace=hypersector.bra_subspace();
        const auto& ket_subspace=hypersector.ket_subspace();
        // if baby spncci subspace correspond to lgi then sigma=omega
        if((bra_subspace.sigma()==bra_subspace.omega())
          &&(ket_subspace.sigma()==ket_subspace.omega())
          )
          {
            // Add hypersector index to irrep family pair set
            std::pair<int,int> irrep_family_pair(hypersector.bra_subspace_index(),hypersector.ket_subspace_index());
            lgi_unit_tensor_subsets[irrep_family_pair].insert(hypersector.operator_subspace_index());
          }
      }
    
    // Starting from lgi unit tensors, generate sets of indices for unit tensor subspaces 
    // organized by NnPairs which will be used to generate the hyperspectors with non-zero
    // blocks between states in irreps
    for(auto it=lgi_unit_tensor_subsets.begin(); it!=lgi_unit_tensor_subsets.end(); ++it)
      {
        // Generate set of unit tensor subspace which will be used to generate hypersectors for each sp irrep pair
        std::map<spncci::NnPair,std::set<int>>& 
          unit_tensor_subsets=unit_tensor_subsets_by_irrep_family[it->first];
        
        const std::set<int>& lgi_unit_tensor_subset=lgi_unit_tensor_subsets[it->first];
        
        spncci::GenerateRecurrenceUnitTensors(
          run_parameters.Nmax,lgi_unit_tensor_space,lgi_unit_tensor_subset,
          unit_tensor_space,unit_tensor_subsets,seed_unit_tensor_lookup_table
          );
      }
  }

  ////////////////////////////////////////////////////////////////
  // read lsu3shell seed unit tensor rmes
  ////////////////////////////////////////////////////////////////
  // timing start
  Timer timer_read_seeds;
  timer_read_seeds.Start();

  std::cout << "Get seed unit tensor rmes..." << std::endl;

  // diagnostic
  std::cout << fmt::format("  seed unit tensors {}",lgi_unit_tensor_labels.size()) << std::endl;
  
  // zero initialize lgi hyperblocks 
  basis::OperatorHyperblocks<double> lgi_hyperblocks;
  basis::SetHyperoperatorToZero(lgi_baby_spncci_hypersectors,lgi_hyperblocks);

  // for each unit tensor, read in unit tensor lsu3shell rmes and transform to spncci basis
  // Store each unit tensor block in appropriate hyperblock
  for (int unit_tensor_index=0; unit_tensor_index<lgi_unit_tensor_labels.size(); ++unit_tensor_index)
    {
      const u3shell::RelativeUnitTensorLabelsU3ST& unit_tensor_labels = lgi_unit_tensor_labels[unit_tensor_index];

      // get hypersector index 
      u3::SU3 x0; 
      HalfInt S0,T0,Sp,Tp,S,T;
      int etap,eta;
      std::tie(x0,S0,T0,etap,Sp,Tp,eta,S,T)=unit_tensor_labels.FlatKey();

      u3shell::UnitTensorSubspaceLabels unit_tensor_subspace_labels(x0,S0,etap,eta);
      int unit_tensor_subspace_index=lgi_unit_tensor_space.LookUpSubspaceIndex(unit_tensor_subspace_labels);

      auto& subspace=lgi_unit_tensor_space.GetSubspace(unit_tensor_subspace_index);
      int unit_tensor_state_index=subspace.LookUpStateIndex(std::tuple<int,int,int,int,int>(int(T0), int(Sp),int(Tp),int(S),int(T)));

      // basis::MatrixVector lgi_unit_tensor_lsu3shell_matrices;
      u3shell::SectorsU3SPN unit_tensor_sectors;
      std::string filename = fmt::format(run_parameters.relative_unit_tensor_filename_template,unit_tensor_index);
      basis::MatrixVector unit_tensor_spncci_matrices;

      // transform to SpNCCI LGI RMEs
      spncci::ReadAndTransformSeedUnitTensorRMEs(
          lsu3shell_basis_table,lsu3shell_space, lgi_expansions,
          unit_tensor_labels,filename,
          unit_tensor_sectors,
          unit_tensor_spncci_matrices
        );

      // map seed blocks into lgi hyperblocks
      {
        // Extract as function
        for(int sector_index=0; sector_index<unit_tensor_sectors.size(); ++sector_index)
            {
              // extract U3SPN sector information
              const typename u3shell::SectorsU3SPN::SectorType& sector = unit_tensor_sectors.GetSector(sector_index);
              const int bra_subspace_index = sector.bra_subspace_index();
              const int ket_subspace_index = sector.ket_subspace_index();
              const u3shell::SubspaceU3SPN bra_subspace=sector.bra_subspace();
              const u3shell::SubspaceU3SPN ket_subspace=sector.ket_subspace();
              const u3::U3& bra_sigma = bra_subspace.U3();
              const u3::U3& ket_sigma = ket_subspace.U3();

              const int rho0 = unit_tensor_sectors.GetSector(sector_index).multiplicity_index();

              // Get baby spncci index 
              spncci::BabySpNCCISubspaceLabels 
                baby_spncci_bra(bra_sigma,bra_subspace.Sp(),bra_subspace.Sn(), bra_subspace.S(),bra_sigma);
              spncci::BabySpNCCISubspaceLabels 
                baby_spncci_ket(ket_sigma,ket_subspace.Sp(),ket_subspace.Sn(), ket_subspace.S(), ket_sigma);

              int index_bra=baby_spncci_space.LookUpSubspaceIndex(baby_spncci_bra);
              int index_ket=baby_spncci_space.LookUpSubspaceIndex(baby_spncci_ket);

              int hypersector_index=lgi_baby_spncci_hypersectors.LookUpHypersectorIndex(index_bra,index_ket,unit_tensor_subspace_index,rho0);
              lgi_hyperblocks[hypersector_index][unit_tensor_state_index]=unit_tensor_spncci_matrices[sector_index];
            }
      }
    }

  timer_read_seeds.Stop();
  std::cout << fmt::format("(Task time: {})",timer_read_seeds.ElapsedTime()) << std::endl;

  ////////////////////////////////////////////////////////////////
  // recurse unit tensor rmes to full SpNCCI basis
  ////////////////////////////////////////////////////////////////
  // for each irrep family compute unit tensor blocks 
  for(auto it=unit_tensor_subsets_by_irrep_family.begin(); it!=unit_tensor_subsets_by_irrep_family.end(); ++it)
    {
      int bra_spncci_index, ket_spncci_index;
      std::tie(bra_spncci_index,ket_spncci_index)=it->first;
      std::map<spncci::NnPair,std::set<int>>& operator_subsets=it->second;
    
      // generate baby spncci hypersectors for given irrep family
      std::vector<std::vector<int>> unit_tensor_hypersector_subsets;
      spncci::BabySpNCCIHypersectors 
        baby_spncci_hypersectors(
          baby_spncci_space, unit_tensor_space, 
          operator_subsets, unit_tensor_hypersector_subsets,
          bra_spncci_index, ket_spncci_index
        );

      // zero initialize hypersectors 
      basis::OperatorHyperblocks<double> unit_tensor_hyperblocks;
      basis::SetHyperoperatorToZero(baby_spncci_hypersectors,unit_tensor_hyperblocks);

      // Populate hypersectors with seeds
      for(int hypersector_index : unit_tensor_hypersector_subsets[0])
        {
          const auto& 
            hypersector=baby_spncci_hypersectors.GetHypersector(hypersector_index);

          int bra_subspace_index=hypersector.bra_subspace_index();
          int ket_subspace_index=hypersector.ket_subspace_index();
          int operator_subspace_index=hypersector.operator_subspace_index();
          int rho0=hypersector.multiplicity_index();
          int lgi_operator_subspace_index
            =seed_unit_tensor_lookup_table[operator_subspace_index];
          int lgi_hypersector_index
            =lgi_baby_spncci_hypersectors.LookUpHypersectorIndex(bra_subspace_index, ket_subspace_index,operator_subspace_index,rho0);

          for(int i=0; i<lgi_hyperblocks[lgi_hypersector_index].size(); ++i)
            unit_tensor_hyperblocks[hypersector_index][i]=lgi_hyperblocks[lgi_hypersector_index][i];
        }

      // Recurse over unit tensor hyper sectors 
      // Contract and regroup
    }


}
