/****************************************************************
  spncci.cpp

  Tests of explicit SpNCCI basis construction in LSU3Shell basis.

  This code just tests normalization, but using clean refactored
  infrastructure.  Other deeper tests (of unit tensor matrix elements)
  were carried out in compute_unit_tensor_rmes.cpp.

  Required data:

  * Relative operator lsu3shell rme input files are generated by

      generate_lsu3shell_relative_operators.cpp

    which is invoked through scripting in

      compute_relative_tensors_lsu3shell_rmes.py

    Example: Z=3 N=3 twice_Nsigma0=22 Nmax=2 Nstep=2 N1v[=N1b]=1
   
    % python3 script/compute_relative_tensors_lsu3shell_rmes.py 3 3 22 2 2 1

    Only need .rme and .dat files.

    Not saved to repository since ~3.5 Mb...

       data/lsu3shell/lsu3shell_rme_6Li_Nmax02
    
  * Relative Hamiltonian (and observable) upcoupled rme files are
    generated by

      generate_relative_u3st_operators

    which is invoked manually for now as

      generate_relative_u3st_operators A Nmax N1v basename

   Example:

       ../operators/generate_relative_u3st_operators 6 2 1 hamiltonian

       with hamiltonian.load containing

       20    // hw
       Tintr 1.0    // coef
       INT 1.0 4 0 0 0 relative_observables/JISP16_Nmax20_hw20.0_rel.dat      // coef Jmax J0 T0 g0 interaction_filename

       ../operators/generate_relative_u3st_operators 6 2 1 Nintr

       with Nintr.load containing

       20    // hw
       Nintr 1.0    // coef

       ../operators/generate_relative_u3st_operators 6 2 1 r2intr

       with r2intr.load containing

       20    // hw
       r2intr 1.0    // coef

   % ln -s ../../data/relative_observables/

         
     

  Anna E. McCoy and Mark A. Caprio
  University of Notre Dame

  2/20/17 (mac): Created (starting from explicit.cpp).
  6/5/17 (mac): Read relative rather than intrinsic symplectic operators.
****************************************************************/

#include <cstdio>
#include <ctime>
#include <fstream>
#include <sys/resource.h>

#include "SymEigsSolver.h"  // from spectra

#include "cppformat/format.h"
#include "mcutils/parsing.h"
#include "lgi/lgi_solver.h"
#include "mcutils/profiling.h"
#include "spncci/computation_control.h"
#include "spncci/explicit_construction.h"
#include "spncci/io_control.h"
#include "spncci/branching.h"
#include "spncci/branching_u3s.h"
#include "spncci/branching_u3lsj.h"
// to vett as moved into computation_control 
#include "mcutils/eigen.h"

////////////////////////////////////////////////////////////////
// WIP code
//
// to extract to spncci library when ready
////////////////////////////////////////////////////////////////
  
namespace spncci
{
  void
  ReadRelativeObservables(
    int Nmax, int N1v, const std::vector<double>& hw_values,
    const std::string& observable_directory,const std::vector<std::string>& observable_filenames, 
    const u3shell::RelativeUnitTensorSpaceU3S& unit_tensor_space,
    std::vector<std::vector<u3shell::RelativeRMEsU3SSubspaces>>& observables_relative_rmes,
    std::vector<std::vector<u3shell::IndexedOperatorLabelsU3S>>& observable_symmetries_u3s
    )
  // Reads in relative observable U(3)xSU(2)xSU(2) tensor components
  // in from files and generates a list of observable symmetries
  // (u3shell::IndexedOperatorLabelsU3S) for each observable.  Tensor
  // components are accumulated over all hw values (interactions may
  // have different tensor components depending on hw value).
  //
  //  Inputs:
  //    Nmax (int) : Oscillator truncation
  //    N1v (int) : Valence shell 
  //    hw_values : list of hw values in mesh
  //    observable_directory : location of observable files
  //    observable_filenames : vector of base names for observable files
  //    unit_tensor_space : set of unit tensor subspaces defined by the x0,S0,etap,eta unit tensor labels
  //
  //  Output:
  //    observables_relative_rmes : array of containers for observable rmes, indexed by hw, then by observable
  //    observable_symmetries_u3s : vector of lists of u3s symmetries for each observable, to be used to construct
  //      U3S sectors. 
  {
  ///////////////////////////////////////////////////////////////////////////////////////////////////
  //  Read in observables  
  ///////////////////////////////////////////////////////////////////////////////////////////////////        
  int num_observables=observable_filenames.size();

  std::cout << "Read observable relative rmes..." << std::endl;
  // observables_relative_rmes.resize(num_observables);  
  // observable_symmetries_u3s.resize(num_observables); 
  observables_relative_rmes.resize(hw_values.size());  
  observable_symmetries_u3s.resize(hw_values.size()); 

  // resizing containers for each hbar omega
  for(int h=0; h<hw_values.size(); ++h)
    observables_relative_rmes[h].resize(num_observables);

  // for each observable, loop over all hw values, read in rmes from file and generate set of symmetry labels
  for (int observable_index=0; observable_index<num_observables; ++observable_index)
    {      
      // temporary container for accumulating set of symmetry labels over hw values for each operator
      std::unordered_set<u3shell::IndexedOperatorLabelsU3S, boost::hash<u3shell::IndexedOperatorLabelsU3S>> symmetries_u3s;
      
      // for each value of hbar omega
      for(int h=0; h<hw_values.size(); ++h)
        {
          double hw=hw_values[h];

          std::string observable_filename
            =fmt::format(
              "{}/{}_hw{:2.1f}_Nmax{:02d}_u3st.dat", 
              observable_directory,observable_filenames[observable_index],hw,Nmax
              );

          std::cout << fmt::format("  Reading {}...",observable_filename)<< std::endl;

          u3shell::RelativeRMEsU3SSubspaces& relative_rmes=observables_relative_rmes[h][observable_index];
          u3shell::ReadRelativeOperatorU3ST(Nmax, N1v,observable_filename,unit_tensor_space,relative_rmes);
          std::cout<<"finished reading "<<std::endl;
          // turn into function
          for(auto it=relative_rmes.begin(); it!=relative_rmes.end(); ++it)
            {
              int unit_tensor_subspace_index, kappa0,L0,etap,eta;
              HalfInt S0;
              u3::SU3 x0;
              std::tie(unit_tensor_subspace_index,kappa0,L0)=it->first;
              std::tie(x0,S0,etap,eta)=unit_tensor_space.GetSubspace(unit_tensor_subspace_index).labels();
              symmetries_u3s.insert(u3shell::IndexedOperatorLabelsU3S(u3shell::OperatorLabelsU3S(etap-eta,x0,S0),kappa0,L0));
            }
          std::cout<<"got the symmetries "<<std::endl;
        }
      std::cout<<"put the tensors in the vector"<<std::endl;
      for(auto tensor : symmetries_u3s)
        observable_symmetries_u3s[observable_index].push_back(tensor);
    }
  }

void GetUnitTensorSeedBlocks(
  const std::vector<u3shell::RelativeUnitTensorLabelsU3ST>& lgi_unit_tensor_labels,
  const u3shell::RelativeUnitTensorSpaceU3S& unit_tensor_space,
  const std::string& relative_unit_tensor_filename_template,
  const u3shell::SpaceU3SPN& lsu3shell_space, 
  const lsu3shell::LSU3BasisTable& lsu3shell_basis_table,
  const basis::MatrixVector& lgi_expansions,
  const spncci::BabySpNCCISpace& baby_spncci_space,
  std::map< std::pair<int,int>, std::map<std::pair<int,int>, basis::OperatorBlocks<double>>>& lgi_unit_tensor_blocks
  )
{
  // For each unit tensor, determine corresponding unit tensor subspace, read in lsu3shell rmes and transform
  // blocks to spncci basis.  The spncci unit tensor blocks are stored in lgi_unit_tensor_blocks.  The outer map 
  // is keyed by irrep family pair, the inner map is keyed by a multiplicity tagged unit tensor subspace, i.e.,
  // {<irrep_family_1, irrep_family_2> : {<unit_tensor_subspace_index,outer_multipicity> : <blocks>}}
  // 
  for (int unit_tensor_index=0; unit_tensor_index<lgi_unit_tensor_labels.size(); ++unit_tensor_index)
    {
      const u3shell::RelativeUnitTensorLabelsU3ST& unit_tensor_labels = lgi_unit_tensor_labels[unit_tensor_index];

      // get hypersector index 
      u3::SU3 x0; 
      HalfInt S0,T0,Sp,Tp,S,T;
      int etap,eta;
      std::tie(x0,S0,T0,etap,Sp,Tp,eta,S,T)=unit_tensor_labels.FlatKey();

      u3shell::UnitTensorSubspaceLabels unit_tensor_subspace_labels(x0,S0,etap,eta);
      int unit_tensor_subspace_index=unit_tensor_space.LookUpSubspaceIndex(unit_tensor_subspace_labels);

      auto& subspace=unit_tensor_space.GetSubspace(unit_tensor_subspace_index);
      int unit_tensor_state_index=subspace.LookUpStateIndex(std::tuple<int,int,int,int,int>(int(T0), int(Sp),int(Tp),int(S),int(T)));

      // basis::MatrixVector lgi_unit_tensor_lsu3shell_matrices;
      u3shell::SectorsU3SPN unit_tensor_sectors;
      std::string filename = fmt::format(relative_unit_tensor_filename_template,unit_tensor_index);
      // temporary container
      basis::MatrixVector unit_tensor_spncci_matrices;

      // generate sector labels 
      const bool spin_scalar = false;
      unit_tensor_sectors = u3shell::SectorsU3SPN(lsu3shell_space,unit_tensor_labels,spin_scalar);
      
      // read in lsu3shell rms for unit tensor 
      basis::MatrixVector unit_tensor_lsu3shell_matrices;
      lsu3shell::ReadLSU3ShellRMEs(
          filename,
          lsu3shell_basis_table,lsu3shell_space,
          unit_tensor_labels,unit_tensor_sectors,unit_tensor_lsu3shell_matrices
        );

      // transform seed rmes to SpNCCI basis (among LGIs)
      lgi::TransformOperatorToSpBasis(
          unit_tensor_sectors,lgi_expansions,
          unit_tensor_lsu3shell_matrices,unit_tensor_spncci_matrices
        );

      // map seed blocks into lgi hyperblocks
      for(int sector_index=0; sector_index<unit_tensor_sectors.size(); ++sector_index)
          {
            // Check that the sector is non-zero as defined by the zero_tolerance
            if(mcutils::IsZero(unit_tensor_spncci_matrices[sector_index],spncci::g_zero_tolerance))
              continue;
            
            // extract U3SPN sector information
            const typename u3shell::SectorsU3SPN::SectorType& sector = unit_tensor_sectors.GetSector(sector_index);
            const int bra_subspace_index = sector.bra_subspace_index();
            const int ket_subspace_index = sector.ket_subspace_index();
            const u3shell::SubspaceU3SPN bra_subspace=sector.bra_subspace();
            const u3shell::SubspaceU3SPN ket_subspace=sector.ket_subspace();
            const u3::U3& bra_sigma = bra_subspace.U3();
            const u3::U3& ket_sigma = ket_subspace.U3();
            const int rho0 = unit_tensor_sectors.GetSector(sector_index).multiplicity_index();

            // Get baby spncci index 
            spncci::BabySpNCCISubspaceLabels 
              baby_spncci_bra(bra_sigma,bra_subspace.Sp(),bra_subspace.Sn(), bra_subspace.S(),bra_sigma);
            spncci::BabySpNCCISubspaceLabels 
              baby_spncci_ket(ket_sigma,ket_subspace.Sp(),ket_subspace.Sn(), ket_subspace.S(), ket_sigma);

            int baby_spncci_index_bra=baby_spncci_space.LookUpSubspaceIndex(baby_spncci_bra);
            int baby_spncci_index_ket=baby_spncci_space.LookUpSubspaceIndex(baby_spncci_ket);

            int irrep_family_index_bra=baby_spncci_space.GetSubspace(baby_spncci_index_bra).irrep_family_index();
            int irrep_family_index_ket=baby_spncci_space.GetSubspace(baby_spncci_index_ket).irrep_family_index();
            std::pair<int,int> irrep_family_pair(irrep_family_index_bra,irrep_family_index_ket);
            auto& subspace_blocks=lgi_unit_tensor_blocks[irrep_family_pair];
            
            // If not already in map, need to resize unit tensor block container for given unit tensor subspace
            std::pair<int,int> multiplicity_tagged_unit_tensor_subspace(unit_tensor_subspace_index,rho0);
            if(not subspace_blocks.count(multiplicity_tagged_unit_tensor_subspace))
              subspace_blocks[multiplicity_tagged_unit_tensor_subspace].resize(unit_tensor_space.GetSubspace(unit_tensor_subspace_index).size());

            // Store block
            subspace_blocks[multiplicity_tagged_unit_tensor_subspace][unit_tensor_state_index]=unit_tensor_spncci_matrices[sector_index];
           }
    }
}



void
  GenerateRecurrenceUnitTensors(
      int Nmax,
      const std::set<int>& lgi_operator_subset,
      const u3shell::RelativeUnitTensorSpaceU3S& unit_tensor_space,
      std::map<spncci::NnPair,std::set<int>>& operator_subsets
    )
  // for a single irrep pair, generate the unit tensor subspaces which will
  // appear in the recurrence
  {
    // std::cout<<"Entering Generate Recurrence Unit Tensors "<<std::endl;

    u3::SU3 x0; 
    HalfInt S0;
    int etap,eta;

    // Initialize with values from lgi_operator_subset
    std::set<int>& operator_subset=operator_subsets[spncci::NnPair(0,0)];
    for(int unit_tensor_subspace_index : lgi_operator_subset)
        operator_subset.insert(unit_tensor_subspace_index);

    // Generate non-lgi unit tensor family labels 
    for(int Nsum=0; Nsum<=2*Nmax; Nsum+=2)
      for(int Nn=0; Nn<=std::min(Nsum,Nmax); Nn+=2)
        {
          int Nnp=Nsum-Nn;
          if((Nnp<0)||(Nnp>Nmax))
            continue;

          spncci::NnPair NnpNn2(Nnp,Nn+2);
          spncci::NnPair NnpNn2_conjugate(Nn+2,Nnp);
          // For each source unit tensor, generate related unit tensors in Nnp,Nn+2 sector and Nnp+2,Nn+2 sector
          const std::set<int>& source_operator_subspace_indices=operator_subsets[spncci::NnPair(Nnp,Nn)];
          for(int source_operator_subspace_index : source_operator_subspace_indices)
            {
              
              std::tie(x0,S0,etap,eta)=unit_tensor_space.GetSubspace(source_operator_subspace_index).labels();
              
              // if etap-2 is negative, then not a valid unit tensor subspace
              if((etap-2)>=0)
                {
                  MultiplicityTagged<u3::SU3>::vector x0p_set1=KroneckerProduct(u3::SU3(etap-2,0), u3::SU3(0,eta));
                  for(auto& x0p_tagged : x0p_set1)
                    {
                      u3::SU3 x0p(x0p_tagged.irrep);
                      u3shell::UnitTensorSubspaceLabels unit_tensor_subspace_labels(x0p,S0,etap-2,eta);
                      int operator_subspace_index=unit_tensor_space.LookUpSubspaceIndex(unit_tensor_subspace_labels);
                      // std::cout<<"hi "<<operator_subspace_index<<std::endl;
                      if(operator_subspace_index!=-1)
                        operator_subsets[NnpNn2].insert(operator_subspace_index);

                      // Conjugate tensor
                      u3shell::UnitTensorSubspaceLabels unit_tensor_subspace_labels_conj(u3::Conjugate(x0p),S0,eta,etap-2);
                      int operator_subspace_index_conj=unit_tensor_space.LookUpSubspaceIndex(unit_tensor_subspace_labels_conj);
                      if(operator_subspace_index_conj!=-1)
                        operator_subsets[NnpNn2_conjugate].insert(operator_subspace_index_conj);
                    }
                } 

              MultiplicityTagged<u3::SU3>::vector x0p_set2=KroneckerProduct(u3::SU3(etap,0), u3::SU3(0,eta+2)); 
              for(auto& x0p_tagged : x0p_set2)
                {
                  u3::SU3 x0p(x0p_tagged.irrep);
                  u3shell::UnitTensorSubspaceLabels unit_tensor_subspace_labels(x0p,S0,etap,eta+2);
                  int operator_subspace_index=unit_tensor_space.LookUpSubspaceIndex(unit_tensor_subspace_labels);
                  if(operator_subspace_index!=-1)
                    operator_subsets[NnpNn2].insert(operator_subspace_index);

                  // Conjugate tensor
                  u3shell::UnitTensorSubspaceLabels unit_tensor_subspace_labels_conj(u3::Conjugate(x0p),S0,eta+2,etap);
                  int operator_subspace_index_conj=unit_tensor_space.LookUpSubspaceIndex(unit_tensor_subspace_labels_conj);
                  if(operator_subspace_index_conj!=-1)
                    operator_subsets[NnpNn2_conjugate].insert(operator_subspace_index_conj);

                }

              // Add tensor to Nnp+2,Nn+2 target sector.  Will be valid if Nnp,Nn is valid sector 
              operator_subsets[spncci::NnPair(Nnp+2,Nn+2)].insert(source_operator_subspace_index);

              // Conjugate tensor
              u3shell::UnitTensorSubspaceLabels unit_tensor_subspace_labels_conj(u3::Conjugate(x0),S0,eta,etap);
              int operator_subspace_index_conj=unit_tensor_space.LookUpSubspaceIndex(unit_tensor_subspace_labels_conj);
              if(operator_subspace_index_conj!=-1)
                operator_subsets[spncci::NnPair(Nn+2,Nnp+2)].insert(operator_subspace_index_conj);
            }
        }
  }



void CheckUnitTensorRecurrence(
  int irrep_family_index_bra, int irrep_family_index_ket,
  const u3shell::RelativeUnitTensorSpaceU3S& unit_tensor_space,
  const std::vector<u3shell::RelativeUnitTensorLabelsU3ST>& lgi_unit_tensor_labels,
  const std::string& relative_unit_tensor_filename_template,
  const u3shell::SpaceU3SPN& lsu3shell_space, 
  const lsu3shell::LSU3BasisTable& lsu3shell_basis_table,
  const spncci::SpNCCISpace& spncci_space,
  const spncci::BabySpNCCISpace& baby_spncci_space,
  const basis::MatrixVector& spncci_expansions,
  const spncci::BabySpNCCIHypersectors& baby_spncci_hypersectors,
  const basis::OperatorHyperblocks<double>& unit_tensor_hyperblocks
)
{

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // Checking unit tensors
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  basis::OperatorHyperblocks<double> unit_tensor_hyperblocks_explicit;
  basis::SetHyperoperatorToZero(baby_spncci_hypersectors,unit_tensor_hyperblocks_explicit);

  const u3::U3& sigmap=spncci_space[irrep_family_index_bra].sigma();
  const u3::U3& sigma =spncci_space[irrep_family_index_ket].sigma();

  // basis::OperatorHyperblocks<double> unit_tensor_hyperblocks_explicit;
  // basis::SetHyperoperatorToZero(baby_spncci_hypersectors,unit_tensor_hyperblocks_explicit);
  for (int unit_tensor_index=0; unit_tensor_index<lgi_unit_tensor_labels.size(); ++unit_tensor_index)
    {
      const u3shell::RelativeUnitTensorLabelsU3ST& unit_tensor = lgi_unit_tensor_labels[unit_tensor_index];

      // get hypersector index 
      u3::SU3 x0; 
      HalfInt S0,T0,Sp,Tp,S,T;
      int etap,eta;
      std::tie(x0,S0,T0,etap,Sp,Tp,eta,S,T)=unit_tensor.FlatKey();

      u3shell::UnitTensorSubspaceLabels unit_tensor_subspace_labels(x0,S0,etap,eta);
      int unit_tensor_subspace_index=unit_tensor_space.LookUpSubspaceIndex(unit_tensor_subspace_labels);

      auto& subspace=unit_tensor_space.GetSubspace(unit_tensor_subspace_index);
      int unit_tensor_state_index
        =subspace.LookUpStateIndex(std::tuple<int,int,int,int,int>(int(T0), int(Sp),int(Tp),int(S),int(T)));

      const bool spin_scalar = false;
      u3shell::SectorsU3SPN unit_tensor_sectors;
      unit_tensor_sectors = u3shell::SectorsU3SPN(lsu3shell_space,unit_tensor,spin_scalar);
      
      // read in lsu3shell rms for unit tensor 
      basis::MatrixVector unit_tensor_lsu3shell_blocks;
      std::string filename = fmt::format(relative_unit_tensor_filename_template,unit_tensor_index);
      lsu3shell::ReadLSU3ShellRMEs(
          filename,
          lsu3shell_basis_table,lsu3shell_space,
          unit_tensor,unit_tensor_sectors,unit_tensor_lsu3shell_blocks
        );

      spncci::ComputeUnitTensorSectorsExplicit(
        sigmap, sigma, unit_tensor,unit_tensor_space,
        lsu3shell_space,unit_tensor_sectors,unit_tensor_lsu3shell_blocks,
        baby_spncci_space, spncci_expansions,baby_spncci_hypersectors,
        unit_tensor_hyperblocks_explicit
      );

      if(not (sigmap==sigma))
      {
        spncci::ComputeUnitTensorSectorsExplicit(
          sigma, sigmap, unit_tensor,unit_tensor_space,
          lsu3shell_space,unit_tensor_sectors,unit_tensor_lsu3shell_blocks,
          baby_spncci_space, spncci_expansions,baby_spncci_hypersectors,
          unit_tensor_hyperblocks_explicit
        );
      }
    }
  bool errors=false;
  for(int i=0; i<unit_tensor_hyperblocks.size(); ++i)
    for(int j=0; j<unit_tensor_hyperblocks[i].size(); ++j)
      {
        auto& hypersector=baby_spncci_hypersectors.GetHypersector(i);
        int bra, ket, tensor, rho0;
        std::tie(bra,ket,tensor,rho0)=hypersector.Key();
        auto& bra_subspace=baby_spncci_space.GetSubspace(bra);
        auto& ket_subspace=baby_spncci_space.GetSubspace(ket);
        auto& tensor_subspace=unit_tensor_space.GetSubspace(tensor);
        const Eigen::MatrixXd matrix1=unit_tensor_hyperblocks[i][j];
        const Eigen::MatrixXd matrix2=unit_tensor_hyperblocks_explicit[i][j];
        // std::cout<<"hyperblock "<<i<<std::endl;
        // std::cout<<matrix1-matrix2<<std::endl;
        if(not mcutils::IsZero(matrix1-matrix2, 1e-4))
          {
            errors=true;
            std::cout<<"hyperblock "<<i<<" sub-block "<<j<<" is not correct"<<std::endl;
            std::cout<<bra_subspace.LabelStr()<<"  "<<ket_subspace.LabelStr()<<"  "<<tensor_subspace.LabelStr()<<"  "
            << rho0<<std::endl;
            std::cout<<"the matrix should be "<<bra_subspace.size()<<" x "<<ket_subspace.size()<<std::endl;
            std::cout<<"gammma_max: "<<ket_subspace.gamma_max()<<" upsilon_max "<<ket_subspace.upsilon_max()<<std::endl;
            std::cout<<"matrix1"<<std::endl<<matrix1<<std::endl<<"matrix2"
            <<std::endl<<matrix2<<std::endl;
          }
      }
  assert(not errors);
  if(not errors)
    std::cout<<"no errors"<<std::endl;

}

void PrintHypersectors(
  const spncci::BabySpNCCISpace& baby_spncci_space,
  const u3shell::RelativeUnitTensorSpaceU3S& unit_tensor_space,
  const spncci::BabySpNCCIHypersectors& baby_spncci_hypersectors,
  const basis::OperatorHyperblocks<double>& unit_tensor_hyperblocks
  )
{
  for(int hypersector_index=0; hypersector_index<baby_spncci_hypersectors.size(); ++hypersector_index)
  {
    const auto& hypersector=baby_spncci_hypersectors.GetHypersector(hypersector_index);
    
    int unit_tensor_subspace_index, ket_subspace_index,bra_subspace_index, rho0;
    std::tie(bra_subspace_index, ket_subspace_index,unit_tensor_subspace_index,rho0)=hypersector.Key();

    //REMOVE
    if(bra_subspace_index!=ket_subspace_index)
      continue;

    const auto& unit_tensor_subspace=unit_tensor_space.GetSubspace(unit_tensor_subspace_index);
    const auto& bra_subspace=baby_spncci_space.GetSubspace(bra_subspace_index);
    const auto& ket_subspace=baby_spncci_space.GetSubspace(ket_subspace_index);

    std::cout<<"hypersector "<<hypersector_index<<" "<< bra_subspace.LabelStr()<<"  "<<ket_subspace.LabelStr()
    <<"  "<<unit_tensor_subspace.LabelStr()<<rho0<<std::endl;
    for(int i=0; i<unit_tensor_subspace.size(); ++i)
    {
      int T0,Sp,Tp,S,T;
      std::tie(T0,Sp,Tp,S,T)=unit_tensor_subspace.GetStateLabels(i);
      std::cout<<fmt::format("{}  {} {}  {} {}",T0,Sp,Tp,S,T)<<std::endl;
      std::cout<<unit_tensor_hyperblocks[hypersector_index][i]<<std::endl<<std::endl;
    }
  }

}


  void
  WriteEigenValues(
    const std::vector<HalfInt>& J_values, double hw, 
    int Nmax, int Nsigma0_ex_max,
    std::map<HalfInt,Eigen::VectorXd>& eigenvalues,
    std::vector<std::string>& observable_filenames,
    std::vector<int>& scalar_observable_indices,
    std::vector<std::map<HalfInt,Eigen::VectorXd>>& scalar_observable_expectations,
    std::vector<int>& nonscalar_observable_indices,
    std::vector<std::map<spncci::JPair,Eigen::MatrixXd>>& nonscalar_observable_expectations
  )
  // for observables with J0=0, line them up with energy eigenvalue and read off diagonal matrix elements 
  // for observables with J0!=0, then have their own section --probably do this in the code as well, i.e.,
  {
    std::string filename=fmt::format("eigenvalues_Nmax{:02d}_Nsigma_ex{:02d}.dat",Nmax,Nsigma0_ex_max);
    std::cout<<"writing to file"<<std::endl;
    std::fstream fs;
    const int width=3;
    const int precision=16;
    fs.open (filename, std::fstream::out | std::fstream::app);
    fs << std::setprecision(precision);

    fs << "OUPTPUT from spncci Version 1"<<std::endl<<std::endl;;
    fs << "Scalar observables:";
    for(int i=0; i<scalar_observable_indices.size(); ++i)
      fs <<"  "<<observable_filenames[scalar_observable_indices[i]];
    fs << std::endl;

    fs <<"Nonscalar observables:";
    for(int i=0; i<nonscalar_observable_indices.size(); ++i)
      fs <<"  "<<observable_filenames[nonscalar_observable_indices[i]];

    fs << std::endl<<fmt::format("hw {:2.1f}", hw)<<std::endl;

    for(HalfInt J : J_values)
      {
        Eigen::VectorXd& eigenvalues_J=eigenvalues[J];
        // Eigen::VectorXd& observables=observable_expectations[J];

        for(int i=0; i<eigenvalues_J.size(); ++i)
          {
            double eigenvalue=eigenvalues_J(i);
            std::cout<<fmt::format("{:2d}   {}   {:8.5f}",i, J,eigenvalue);
            fs << fmt::format("{:2d}   {}   {:8.5f}",i, J,eigenvalue);
            
            for(int j=0; j<scalar_observable_indices.size(); ++j)  
            {          
              std::cout<<fmt::format("   {:8.5f}",scalar_observable_expectations[j][J](i))
              <<std::endl<<std::endl;
              fs <<fmt::format("   {:8.5f}",scalar_observable_expectations[j][J](i))
              <<std::endl<<std::endl;
            }
          }
      }
    for(HalfInt J : J_values)
      {
        Eigen::VectorXd& eigenvalues_J_initial=eigenvalues[J];
        for(int i=0; i<eigenvalues_J_initial.size(); ++i)
          for(HalfInt Jp :J_values)
          {
            Eigen::VectorXd& eigenvalues_J_final=eigenvalues[Jp];
            spncci::JPair J_pair(Jp,J);
            for(int ip=0; ip<eigenvalues_J_final.size(); ++ip)
              {
                double eigenvalue_initial=eigenvalues_J_initial(i);
                double eigenvalue_final=eigenvalues_J_final(ip);
                fs << fmt::format("{:2d}   {}   {:2d}   {}   {:8.5f}   {:8.5f}",
                      i,J,ip,Jp,eigenvalue_initial,eigenvalue_final);

                for(int j=0; j<nonscalar_observable_indices.size(); ++j)
                  {
                    // std::cout<<"(ip, i) ("<<ip<<","<<i<<")"<<std::endl;
                    Eigen::MatrixXd& obserable_matrix=nonscalar_observable_expectations[j][J_pair];
                    // std::cout<<obserable_matrix<<std::endl;
                    double observable=obserable_matrix(ip,i);
                    fs<<fmt::format("  {:8.5f}",observable);
                  }
                fs<<std::endl;
              }
          }
      }
    fs<<std::endl<<std::endl;
    fs.close();
  }

}// end namespace

////////////////////////////////////////////////////////////////
// run parameters
////////////////////////////////////////////////////////////////

struct RunParameters
// Structure to store input parameters for run.
//
// Data members:
//   A (int): Atomic mass.
//   ...
{

  // constructor
  RunParameters(int argc, char **argv); 

  // basis parameters
  int A;
  HalfInt Nsigma_0;
  int Nsigma0_ex_max;
  int N1v;
  int Nmax;

  // filenames
  std::string lsu3shell_rme_directory;
  std::string lsu3shell_basis_filename;
  std::string Brel_filename;
  std::string Arel_filename;
  std::string Nrel_filename;
  std::string relative_unit_tensor_filename_template;

  // many-body problem
  std::string observable_directory;
  std::vector<std::string> observable_filenames;  // first observable is used as Hamiltonian
  std::vector<int> observable_Jvalues;
  int num_observables;
  std::vector<HalfInt> J_values;
  std::vector<double> hw_values;

  // eigensolver
  int num_eigenvalues;
  int eigensolver_num_convergence;  // whatever exactly this is...
  int eigensolver_max_iterations;
  double eigensolver_tolerance;

};

RunParameters::RunParameters(int argc, char **argv)
{
  // read from command line arguments
  //
  // TODO reorder filenames 
  if (argc<5)
    {
      std::cout << "Syntax: A twice_Nsigma0 Nsigma0_ex_max N1v Nmax num_eigenvalues <load file>"
       // <basis filename> <Nrel filename> <Brel filename> <Arel filename>" 
                << std::endl;
      std::exit(1);
    }
  A = std::stoi(argv[1]); 
  int twice_Nsigma0= std::stoi(argv[2]);
  Nsigma0_ex_max=std::stoi(argv[3]);
  Nsigma_0=HalfInt(twice_Nsigma0,2);
  N1v=std::stoi(argv[4]);
  Nmax = std::stoi(argv[5]);
  num_eigenvalues=std::stoi(argv[6]);
  std::string load_file=argv[7];

  // std::cout<< fmt::format("{} {} {} {} {} {}",A, twice_Nsigma0, Nsigma_0, Nsigma0_ex_max, N1v, Nmax)<<std::endl;
  
  // many-body problem
  // observable_filenames = std::vector<std::string>({"hamiltonian_u3st.dat"});

  // Reading in from load life 
  int line_count=0;
  int twice_Jmin, twice_Jmax, J_step;
  double hw_min, hw_max, hw_step;
  std::string line, observable;
  std::ifstream is(fmt::format("{}.load",load_file));
  
  assert(is);
  int J0;
  while(std::getline(is,line))
    {
      std::istringstream line_stream(line);
      ++line_count;
      if(line_count==1)
      {
        line_stream >> twice_Jmin >> twice_Jmax >> J_step;
        ParsingCheck(line_stream,line_count,line);
      }
      else if(line_count==2)
      {
        line_stream >> hw_min >> hw_max >> hw_step;
        ParsingCheck(line_stream,line_count,line);
      }
      else
      {
        line_stream >> observable >> J0;
        ParsingCheck(line_stream,line_count,line);
        observable_filenames.push_back(observable);
        observable_Jvalues.push_back(J0);
      }
    }

  num_observables = observable_filenames.size();
  observable_directory="relative_observables";
  // generate list of J values 
  HalfInt Jmin(twice_Jmin,2);
  HalfInt Jmax(twice_Jmax,2);
  for(HalfInt J=Jmin; J<=Jmax; J+=J_step)
    J_values.push_back(J);

  std::cout<<"J values are: ";
  for(auto J : J_values)
    std::cout<<J<<"  ";
  std::cout<<std::endl;

  for(double hw=hw_min; hw<=hw_max; hw+=hw_step)
    hw_values.push_back(hw);

  std::cout<<"hw values are: ";
  for(auto hw : hw_values)
    std::cout<<hw<<"  ";
  std::cout<<std::endl;


  // hard-coded directory structure and filenames
  lsu3shell_rme_directory = "lsu3shell_rme";
  lsu3shell_basis_filename = lsu3shell_rme_directory + "/" + "lsu3shell_basis.dat";
  Brel_filename = lsu3shell_rme_directory + "/" + fmt::format("Brel.rme",Nsigma0_ex_max);
  Arel_filename = lsu3shell_rme_directory + "/" + fmt::format("Arel.rme",Nsigma0_ex_max);
  Nrel_filename = lsu3shell_rme_directory + "/" + fmt::format("Nrel.rme",Nsigma0_ex_max);
  relative_unit_tensor_filename_template = lsu3shell_rme_directory + "/" + "relative_unit_{:06d}.rme";

  // hard-coded eigen solver parameters   
  eigensolver_num_convergence = 2*num_eigenvalues;    // docs for SymEigsSolver say to take "ncv>=2*nev"
  eigensolver_max_iterations = 100*num_eigenvalues;
  eigensolver_tolerance = 1e-8;
}


////////////////////////////////////////////////////////////////
// main body
////////////////////////////////////////////////////////////////

int main(int argc, char **argv)
{
  std::cout<<"entering spncci"<<std::endl;
  ////////////////////////////////////////////////////////////////
  // initialization
  ////////////////////////////////////////////////////////////////
  
  // SU(3) caching
  u3::U3CoefInit();
  u3::UCoefCache u_coef_cache;
  u3::PhiCoefCache phi_coef_cache;
  u3::g_u_cache_enabled = true;

  // numerical parameter for certain calculations
  double zero_threshold=1e-8;  // DEPRECATED but still may be used some places
  spncci::g_zero_tolerance = 1e-6;
  spncci::g_suppress_zero_sectors = true;

  // run parameters
  RunParameters run_parameters(argc,argv);

  // Eigen OpenMP multithreading mode
  Eigen::initParallel();
  // Eigen::setNbThreads(0);

  ////////////////////////////////////////////////////////////////
  // read lsu3shell basis
  ////////////////////////////////////////////////////////////////

  std::cout << "Read lsu3shell basis..." << std::endl;
  // read lsu3shell basis (regroup into U3SPN subspaces)
  lsu3shell::LSU3BasisTable lsu3shell_basis_table;
  lsu3shell::U3SPNBasisLSU3Labels lsu3shell_basis_provenance;
  u3shell::SpaceU3SPN lsu3shell_space;
  lsu3shell::ReadLSU3Basis(
      run_parameters.Nsigma_0,run_parameters.lsu3shell_basis_filename,
      lsu3shell_basis_table,lsu3shell_basis_provenance,lsu3shell_space
    );

  ////////////////////////////////////////////////////////////////
  // solve for LGIs
  ////////////////////////////////////////////////////////////////
  std::cout << "Solve for LGIs..." << std::endl;

  // timing start
  Timer timer_lgi;
  timer_lgi.Start();

  u3shell::SectorsU3SPN Bintr_sectors, Aintr_sectors, Nintr_sectors;
  basis::MatrixVector Bintr_matrices, Aintr_matrices, Nintr_matrices;
  spncci::ReadLSU3ShellSymplecticOperatorRMEs(
      lsu3shell_basis_table,lsu3shell_space, 
      run_parameters.Brel_filename,Bintr_sectors,Bintr_matrices,
      run_parameters.Arel_filename,Aintr_sectors,Aintr_matrices,
      run_parameters.Nrel_filename,Nintr_sectors,Nintr_matrices,
      run_parameters.A
    );

  const u3shell::SectorsU3SPN& Ncm_sectors = Nintr_sectors;
  basis::MatrixVector Ncm_matrices;
  lsu3shell::GenerateLSU3ShellNcmRMEs(
      lsu3shell_space,Nintr_sectors,Nintr_matrices,
      run_parameters.A,
      Ncm_matrices
    );

  lgi::MultiplicityTaggedLGIVector lgi_families;
  basis::MatrixVector lgi_expansions;

  lgi::GenerateLGIExpansion(
      lsu3shell_space, 
      Bintr_sectors,Bintr_matrices,Ncm_sectors,Ncm_matrices,
      run_parameters.Nsigma_0,
      lgi_families,lgi_expansions
    );

  // diagnostics
  std::cout << fmt::format("  LGI families {}",lgi_families.size()) << std::endl;
  if (false)
    lgi::WriteLGILabels(lgi_families,std::cout);

  // timing stop
  timer_lgi.Stop();
  std::cout << fmt::format("(Task time: {})",timer_lgi.ElapsedTime()) << std::endl;

  ////////////////////////////////////////////////////////////////
  // set up SpNCCI space
  ////////////////////////////////////////////////////////////////

  std::cout << "Set up SpNCCI space..." << std::endl;

  // build SpNCCI irrep branchings
  spncci::SpNCCISpace spncci_space;
  spncci::SigmaIrrepMap sigma_irrep_map;  // persistent container to store branchings
  spncci::NmaxTruncator truncator(run_parameters.Nsigma_0,run_parameters.Nmax);
  spncci::GenerateSpNCCISpace(lgi_families,truncator,spncci_space,sigma_irrep_map);

  // diagnostics
  std::cout << fmt::format("  Irrep families {}",spncci_space.size()) << std::endl;
  std::cout << fmt::format("  TotalU3Subspaces {}",spncci::TotalU3Subspaces(spncci_space)) << std::endl;
  std::cout << fmt::format("  TotalDimensionU3 {}",spncci::TotalDimensionU3S(spncci_space)) << std::endl;


  // // build SpNCCI irrep branchings for LGI's
  // spncci::SpNCCISpace lgi_spncci_space;
  // spncci::SigmaIrrepMap lgi_sigma_irrep_map;  // persistent container to store branchings
  // spncci::NmaxTruncator lgi_truncator(run_parameters.Nsigma_0,run_parameters.Nsigma0_ex_max);
  // spncci::GenerateSpNCCISpace(lgi_families,lgi_truncator,lgi_spncci_space,lgi_sigma_irrep_map);

  // build baby spncci space 
  spncci::BabySpNCCISpace baby_spncci_space(spncci_space);

  // build U3S gathered space
  std::cout << "Build SpaceSpU3S..." << std::endl;
  spncci::SpaceSpU3S space_spu3s(baby_spncci_space);
  std::cout << fmt::format("  subspaces {} full_dimension {}",space_spu3s.size(),space_spu3s.TotalFullDimension())
            << std::endl;
  // std::cout << space_spu3s.DebugStr(true);


  ////////////////////////////////////////////////////////////////
  // precompute K matrices
  ////////////////////////////////////////////////////////////////
  std::cout << "Precompute K matrices..." << std::endl;

  // timing start
  Timer timer_k_matrices;
  timer_k_matrices.Start();

  // traverse distinct sigma values in SpNCCI space, generating K
  // matrices for each
  spncci::KMatrixCache k_matrix_cache;
  bool intrinsic = true;
  spncci::PrecomputeKMatrices(sigma_irrep_map,k_matrix_cache,intrinsic);

  // timing stop
  timer_k_matrices.Stop();
  std::cout << fmt::format("(Task time: {})",timer_k_matrices.ElapsedTime()) << std::endl;

  std::cout<<"Kmatrices "<<std::endl;

  for(auto it=k_matrix_cache.begin(); it!=k_matrix_cache.end(); ++it)
    {
      std::cout<<"sigma "<<it->first.Str()<<std::endl;
      for(auto it2=it->second.begin();  it2!=it->second.end(); ++it2)
      {
        std::cout<<"  omega"<<it2->first.Str()<<std::endl;
        std::cout<<it2->second<<std::endl;
      }
    }

  ///////////////////////////////////////////////////////////////////////////////////////////////////
  // Enumerate unit tensor space 
  ///////////////////////////////////////////////////////////////////////////////////////////////////
  int J0_for_unit_tensors = -1;  // all J0
  int T0_for_unit_tensors = -1;  // all T0
  const bool restrict_positive_N0 = false;  // don't restrict to N0 positive

  // get full set of possible unit tensor labels up to Nmax, N1v truncation
  std::vector<u3shell::RelativeUnitTensorLabelsU3ST> unit_tensor_labels;  
  u3shell::GenerateRelativeUnitTensorLabelsU3ST(
    run_parameters.Nmax, run_parameters.N1v,
    unit_tensor_labels,J0_for_unit_tensors,T0_for_unit_tensors,
    restrict_positive_N0
    );

  // for(auto tensor :unit_tensor_labels)
  //   std::cout<<tensor.Str()<<std::endl;

  // generate unit tensor subspaces 
  u3shell::RelativeUnitTensorSpaceU3S 
    unit_tensor_space(run_parameters.Nmax,run_parameters.N1v,unit_tensor_labels);

  // ///////////////////////////////////////////////////////////////////////////////////////////////////
  // //  For testing, get lsu3shell expansion of full spncci basis
  // ///////////////////////////////////////////////////////////////////////////////////////////////////        
  // if(run_parameters.Nmax==run_parameters.Nsigma0_ex_max)
  // {
  // basis::MatrixVector spncci_expansions;
  // spncci::ConstructSpNCCIBasisExplicit(
  //     lsu3shell_space,spncci_space,lgi_expansions,baby_spncci_space,
  //     k_matrix_cache,Aintr_sectors,Aintr_matrices,spncci_expansions
  //   );
  // }

  ///////////////////////////////////////////////////////////////////////////////////////////////////
  //  Read in observables  
  ///////////////////////////////////////////////////////////////////////////////////////////////////        
  // Initialize containers for rmes and their symmetries 
  // Stored by hw, then by observable
  std::vector<std::vector<u3shell::RelativeRMEsU3SSubspaces>> observables_relative_rmes(run_parameters.hw_values.size());
  std::vector<std::vector<u3shell::IndexedOperatorLabelsU3S>> observable_symmetries_u3s(run_parameters.num_observables); 

  spncci::ReadRelativeObservables(
    run_parameters.Nmax, run_parameters.N1v, run_parameters.hw_values,
    run_parameters.observable_directory,run_parameters.observable_filenames, 
    unit_tensor_space, observables_relative_rmes, observable_symmetries_u3s
  );

  // // set up U3S sectors for each of the observables 
  // // Was the function ConstructObservablesU3S
  ///////////////////////////////////////////////////////////////////////////////////////////////
  std::cout<<"setting up u3 sectors "<<std::endl;
  // enumerate u3S space from baby spncci for each observable 
  spncci::SpaceU3S space_u3s(baby_spncci_space);

  // vector of sectors for each observable
  std::vector<std::vector<spncci::SectorLabelsU3S>> observables_sectors_u3s(run_parameters.num_observables);
  
  // vector of blocks for u3 sectors for each hbar omega,for each observable
  std::vector<std::vector<basis::OperatorBlocks<double>>> observables_blocks_u3s(run_parameters.hw_values.size());

  // for each observable, enumerate sectors 
  for(int observable_index=0; observable_index< run_parameters.num_observables; ++observable_index) 
    {
      std::vector<spncci::SectorLabelsU3S>& sectors_u3s=observables_sectors_u3s[observable_index];
      spncci::GetSectorsU3S(space_u3s,observable_symmetries_u3s[observable_index],sectors_u3s);
    }

      
  // For each hbar omega, zero initialize block for each observable
  // based on basis::SetOperatorToZero in operator.h
  for(int h=0; h<run_parameters.hw_values.size(); ++h)
    {
      std::vector<basis::OperatorBlocks<double>>& observables_blocks=observables_blocks_u3s[h];
      observables_blocks.resize(run_parameters.num_observables);

      for(int observable_index=0; observable_index<run_parameters.num_observables; ++observable_index)
        {
          basis::OperatorBlocks<double>& blocks=observables_blocks[observable_index];
          std::vector<spncci::SectorLabelsU3S>& sectors_u3s=observables_sectors_u3s[observable_index];
          blocks.resize(sectors_u3s.size());
          for(int sector_index=0; sector_index<sectors_u3s.size(); ++sector_index)
            {
              int rows=space_u3s.GetSubspace(sectors_u3s[sector_index].bra_index()).full_dimension();
              int cols=space_u3s.GetSubspace(sectors_u3s[sector_index].ket_index()).full_dimension();
              blocks[sector_index]=basis::OperatorBlock<double>::Zero(rows,cols);
            }
        }

    } 
  ///////////////////////////////////////////////////////////////////////////////////////////////
  std::cout<<"seting up lgi unit tensor blocks"<<std::endl;
  
  // map of {lgi pair : list of hypersector indices organized by Nsum}
  // Read in lsu3shell unit tensors
  // transform block for each unit tensor to spncci
  // identify unit tensors with non-zero rmes's between each lgi pair 
  // Generate unit tensor labels for recurrence for each lgi pair
  // put seed blocks into hypersector blocks for each lgi pair 

  // Get list of unit tensor labels between lgi's 
  std::vector<u3shell::RelativeUnitTensorLabelsU3ST> lgi_unit_tensor_labels;
  u3shell::GenerateRelativeUnitTensorLabelsU3ST(
    run_parameters.Nsigma0_ex_max, run_parameters.N1v,
    lgi_unit_tensor_labels,J0_for_unit_tensors,T0_for_unit_tensors,
    restrict_positive_N0
    );

  //////////////////////////////////////////////////////////////////////////////////////////
  // for each unit tensor, read in unit tensor lsu3shell rmes and transform to spncci basis
  //////////////////////////////////////////////////////////////////////////////////////////
  // timing start
  Timer timer_read_seeds;
  timer_read_seeds.Start();

  std::cout << "Get seed unit tensor rmes..." << std::endl;
  // diagnostic
  std::cout << fmt::format("  seed unit tensors {}",lgi_unit_tensor_labels.size()) << std::endl;
  
    // Container for lgi unit tensor blocks 
  std::map< std::pair<int,int>, std::map<std::pair<int,int>, basis::OperatorBlocks<double>>> lgi_unit_tensor_blocks;
  
  spncci::GetUnitTensorSeedBlocks(
    lgi_unit_tensor_labels,unit_tensor_space,
    run_parameters.relative_unit_tensor_filename_template,
    lsu3shell_space, lsu3shell_basis_table,
    lgi_expansions, baby_spncci_space,
    lgi_unit_tensor_blocks
    );

  timer_read_seeds.Stop();
  std::cout << fmt::format("(Task time: {})",timer_read_seeds.ElapsedTime()) << std::endl;

  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  //create a map of vectors of unit tensor subspace indices keyed by spncci irrep pairs 
  std::map<std::pair<int,int>,std::set<int>>lgi_unit_tensor_subset;
  for(auto it=lgi_unit_tensor_blocks.begin(); it!=lgi_unit_tensor_blocks.end(); ++it)
    for(auto it2=it->second.begin(); it2!=it->second.end(); ++it2)
      lgi_unit_tensor_subset[it->first].insert(it2->first.first);
  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // for each lgi pair lgi1, lgi2 compute all unit tensor hypersectors for which Nnp<=Nn and 
  // the conjugate hypersectors for Nnp>Nn, i.e., compute <lgi1 Nnp=0 | |lgi2 Nn=2> and 
  // <lgi2 Nn=0| |lgi1 Nnp=2> etc. 

  // Need to add seeds for both lgi pair and conjugate lgi pair
  for(auto it=lgi_unit_tensor_blocks.begin(); it!=lgi_unit_tensor_blocks.end(); ++it)
    {
      int irrep_family_index_bra,irrep_family_index_ket;
      std::tie(irrep_family_index_bra,irrep_family_index_ket)=it->first;
      
      if(irrep_family_index_bra>irrep_family_index_ket)
        continue;      

      if(irrep_family_index_bra!=0 || irrep_family_index_ket!=0)
        continue;

      // get seeds for given lgi pair
      auto& seed_blocks=it->second;  

      // Get operator subset labels     
      const std::set<int>& lgi_unit_tensors=lgi_unit_tensor_subset[it->first];

      // Get full set of unit tensor subspaces for recurrence
      std::map<spncci::NnPair,std::set<int>> unit_tensor_subsets;
      spncci::GenerateRecurrenceUnitTensors(
        run_parameters.Nmax,lgi_unit_tensors,
        unit_tensor_space,unit_tensor_subsets
        );

      // conjugate lgi
      std::pair<int,int> lgi_pair_conjugate(irrep_family_index_ket,irrep_family_index_bra);
      // get set of unit tensors for conjugate pair
      const std::set<int>& lgi_unit_tensors_conjugate=lgi_unit_tensor_subset[lgi_pair_conjugate];      
      const auto& seed_blocks_conjugate=lgi_unit_tensor_blocks[lgi_pair_conjugate];

      // Generate recurrence for conjugate, accumulating in unit_tensor_subset.
      spncci::GenerateRecurrenceUnitTensors(
        run_parameters.Nmax,lgi_unit_tensors_conjugate,
        unit_tensor_space,unit_tensor_subsets
        );

      // generate baby spncci hypersectors for given irrep family from unit tensor subspace
      std::vector<std::vector<int>> unit_tensor_hypersector_subsets(2*run_parameters.Nmax);
      spncci::BabySpNCCIHypersectors 
        baby_spncci_hypersectors(
          baby_spncci_space, unit_tensor_space, 
          unit_tensor_subsets, unit_tensor_hypersector_subsets,
          irrep_family_index_bra, irrep_family_index_ket
        );

      // std::cout<<"number of hypersectors "<<baby_spncci_hypersectors.size()<<std::endl;

      // // std::cout<<"checking hypersector subsets"<<std::endl;
      // for(int N=0; N<unit_tensor_hypersector_subsets.size(); N++)
      //   for(int hypersector_index : unit_tensor_hypersector_subsets[N])
      //     {
      //       // std::cout<<"N="<<N<<std::endl;
      //       const auto& hypersector=baby_spncci_hypersectors.GetHypersector(hypersector_index);
      //       int unit_tensor_subspace_index, ket_subspace_index,bra_subspace_index, rho0;
      //       std::tie(bra_subspace_index, ket_subspace_index,unit_tensor_subspace_index,rho0)=hypersector.Key();
    
      //       const auto& unit_tensor_subspace=unit_tensor_space.GetSubspace(unit_tensor_subspace_index);
      //       const auto& bra_subspace=baby_spncci_space.GetSubspace(bra_subspace_index);
      //       const auto& ket_subspace=baby_spncci_space.GetSubspace(ket_subspace_index);

      //       // std::cout<<"hypersector "<<hypersector_index<<" "<< bra_subspace.LabelStr()<<"  "<<ket_subspace.LabelStr()
      //       // <<"  "<<unit_tensor_subspace.LabelStr()<<rho0<<std::endl;

      //     }

      // zero initialize hypersectors 
      basis::OperatorHyperblocks<double> unit_tensor_hyperblocks;
      basis::SetHyperoperatorToZero(baby_spncci_hypersectors,unit_tensor_hyperblocks);

      if(run_parameters.Nmax==run_parameters.Nsigma0_ex_max)
      {
        basis::OperatorHyperblocks<double> unit_tensor_hyperblocks_explicit;
      basis::SetHyperoperatorToZero(baby_spncci_hypersectors,unit_tensor_hyperblocks_explicit);
      }
      // Populate hypersectors with seeds
      for(int hypersector_index : unit_tensor_hypersector_subsets[0])
        {
          const auto& hypersector=baby_spncci_hypersectors.GetHypersector(hypersector_index);
          int unit_tensor_subspace_index=hypersector.operator_subspace_index();
          int rho0=hypersector.multiplicity_index();
          std::pair<int,int> seed_unit_tensor_key(unit_tensor_subspace_index,rho0);
          
          // Check if hypersector is conjugate
          const auto& bra_subspace=baby_spncci_space.GetSubspace(hypersector.bra_subspace_index());
          const auto& ket_subspace=baby_spncci_space.GetSubspace(hypersector.ket_subspace_index());

          // If conjugate then get blocks from seed_blocks_conjugate
          // otherwise, get seeds from seed blocks.
          bool is_conjugate=(bra_subspace.irrep_family_index()>ket_subspace.irrep_family_index());
          const basis::OperatorBlocks<double>& seeds=is_conjugate?
          seed_blocks_conjugate.at(std::pair<int,int>(unit_tensor_subspace_index,rho0)):
          seed_blocks.at(std::pair<int,int>(unit_tensor_subspace_index,rho0));
          
          for(int i=0; i<seeds.size(); ++i)
            {
              if(seeds[i].rows()==0)
                continue;
              
              unit_tensor_hyperblocks[hypersector_index][i]=seeds[i];
            }
        }

      // std::cout<<"lgi pair "<<irrep_family_index_bra<<"  "<<irrep_family_index_ket<<std::endl;
      // std::cout<<"checking seed hypersectors"<<std::endl;
      // for(int hypersector_index : unit_tensor_hypersector_subsets[0])
      //   {
      //     const auto& hypersector
      //       =baby_spncci_hypersectors.GetHypersector(hypersector_index);
          
      //     int unit_tensor_subspace_index, ket_subspace_index,bra_subspace_index, rho0;
      //     std::tie(bra_subspace_index, ket_subspace_index,unit_tensor_subspace_index,rho0)=hypersector.Key();
  
      //     const auto& unit_tensor_subspace=unit_tensor_space.GetSubspace(unit_tensor_subspace_index);
      //     const auto& bra_subspace=baby_spncci_space.GetSubspace(bra_subspace_index);
      //     const auto& ket_subspace=baby_spncci_space.GetSubspace(ket_subspace_index);

      //     std::cout<<"hypersector "<<hypersector_index<<" "<< bra_subspace.LabelStr()<<"  "<<ket_subspace.LabelStr()
      //     <<unit_tensor_subspace.LabelStr()<<rho0<<std::endl;
      //     for(int i=0; i<unit_tensor_subspace.size(); ++i)
      //       std::cout<<unit_tensor_hyperblocks[hypersector_index][i]<<std::endl<<std::endl;
      //   }

      // Recurse over unit tensor hypersectors 
      // std::cout<<"entering the recurrence for "<<irrep_family_index_bra<<" "<<irrep_family_index_ket<<std::endl;
      spncci::ComputeUnitTensorHyperblocks(
        run_parameters.Nmax,run_parameters.N1v,u_coef_cache,phi_coef_cache,k_matrix_cache,
        spncci_space,baby_spncci_space,unit_tensor_space,
        baby_spncci_hypersectors, unit_tensor_hypersector_subsets,
        unit_tensor_hyperblocks
        );

      std::cout<<"checking hypersectors"<<std::endl;

      spncci::PrintHypersectors(
        baby_spncci_space,unit_tensor_space, 
        baby_spncci_hypersectors,unit_tensor_hyperblocks
        );

      // spncci::CheckUnitTensorRecurrence(
      //   irrep_family_index_bra, irrep_family_index_ket,
      //   unit_tensor_space,lgi_unit_tensor_labels,
      //   run_parameters.relative_unit_tensor_filename_template,
      //   lsu3shell_space, lsu3shell_basis_table,
      //   spncci_space,baby_spncci_space,spncci_expansions,
      //   baby_spncci_hypersectors,unit_tensor_hyperblocks
      // );
      
      // std::cout<<"contracting over observables "<<std::endl;
      for(int observable_index=0; observable_index<run_parameters.num_observables; ++observable_index)
        for(int h=0; h<run_parameters.hw_values.size(); ++h)
          {
            // std::cout<<"observable "<<observable_index<<" hw "<<run_parameters.hw_values[h]<<std::endl;
            const u3shell::RelativeRMEsU3SSubspaces& relative_observable=observables_relative_rmes[h][observable_index];
            const std::vector<spncci::SectorLabelsU3S>& sectors_u3s=observables_sectors_u3s[observable_index];
            basis::OperatorBlocks<double>& blocks_u3s=observables_blocks_u3s[h][observable_index];
      
            ContractAndRegroupU3S(
                unit_tensor_space,baby_spncci_space,
                space_u3s,relative_observable,
                baby_spncci_hypersectors,unit_tensor_hyperblocks,
                sectors_u3s,blocks_u3s
              );      
          }
    }// end lgi_pair

  for(int observable_index=0; observable_index<run_parameters.num_observables; ++observable_index)
    for(int h=0; h<run_parameters.hw_values.size(); ++h)
      {
        std::cout<<"observable "<<observable_index<<" hw "<<run_parameters.hw_values[h]<<std::endl;
        const u3shell::RelativeRMEsU3SSubspaces& relative_observable=observables_relative_rmes[h][observable_index];
        const std::vector<spncci::SectorLabelsU3S>& sectors_u3s=observables_sectors_u3s[observable_index];
        basis::OperatorBlocks<double>& blocks_u3s=observables_blocks_u3s[h][observable_index];
        for(int i=0; i<blocks_u3s.size(); ++i)
          {
            auto& block=blocks_u3s[i];
            const auto& sector=sectors_u3s[i];            
            const auto& bra=space_u3s.GetSubspace(sector.bra_index());
            const auto& ket=space_u3s.GetSubspace(sector.ket_index());
            const auto& op=sector.operator_labels();
            if(not mcutils::IsZero(block))
            {
              std::cout<<bra.Str()<<"  "<<ket.Str()<<"  "<<op.Str()<<std::endl;
              mcutils::ChopMatrix(block, 1e-6);
              std::cout<<block<<std::endl<<std::endl;
            }
          }
      }

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // At this point observable rmes should be fully computed and unit tensor cache, Ucoef cache and Kmatrix cache deleted 
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // loop over hw values, branch matrix sectors and compute eigenvalues
  
  ////////////////////////////////////////////////////////////////
  // branch observables
  ////////////////////////////////////////////////////////////////
  std::cout << "Set up basis indexing for branching..." << std::endl;

  // set up basis indexing for branching
  std::map<HalfInt,spncci::SpaceLS> spaces_lsj;  // map: J -> space
  for (const HalfInt J : run_parameters.J_values)
    {
      spaces_lsj[J] = spncci::SpaceLS(space_u3s,J);
      std::cout << fmt::format("Branching for J={}: LS subspaces {}",J.Str(),spaces_lsj[J].size()) << std::endl;
    }

  std::cout << "Construct branched observable matrices..." << std::endl;

  // timing start
  Timer timer_branching;
  timer_branching.Start();

  // for each hw value, solve eigen problem and get expectation values 
  for(int h=0; h<run_parameters.hw_values.size(); ++h)
  {

    ////////////////////////////////////////////////////////////////
    // Formerly computational_control ConstructBranchedObservables
    ////////////////////////////////////////////////////////////////
    // populate fully-branched many-body matrices for observables

    // map: observable -> J ->  matrix
    std::vector<std::map<std::pair<HalfInt, HalfInt>,Eigen::MatrixXd>> observable_matrices;  
    observable_matrices.resize(run_parameters.num_observables);
    spncci::ConstructBranchedObservables(
      space_u3s,
      observables_sectors_u3s,
      observables_blocks_u3s[h], 
      spaces_lsj,
      run_parameters.num_observables,
      run_parameters.J_values,
      run_parameters.observable_Jvalues, 
      observable_matrices);

    // timing stop
    timer_branching.Stop();
    std::cout << fmt::format("(Task time: {})",timer_branching.ElapsedTime()) << std::endl;

    // diagnostics: branched matrices
    if (false)
      {
        for (int observable_index=0; observable_index<run_parameters.num_observables; ++observable_index)
          for (const HalfInt J : run_parameters.J_values)
            for (const HalfInt Jp : run_parameters.J_values)
              {
                const HalfInt J0=run_parameters.observable_Jvalues[observable_index];
                std::cout<<"Jvalues "<<Jp<<" "<<J0<<" "<<J<<std::endl;
                if(not am::AllowedTriangle(J,J0,Jp))
                  continue;

                const Eigen::MatrixXd& observable_matrix = observable_matrices[observable_index].at(std::make_pair(Jp,J));

                const HalfInt bra_J = Jp;
                const HalfInt ket_J = J;
                std::cout
                  << fmt::format("Observable {} bra_J {} ket_J {} J0 {}",observable_index,bra_J,ket_J, J0)
                  << std::endl;
                std::cout
                  << mcutils::FormatMatrix(observable_matrix,"8.5f")
                  << std::endl
                  << std::endl;

            }
      }
    
    std::map<HalfInt,Eigen::VectorXd> eigenvalues;  // map: J -> eigenvalues
    std::map<HalfInt,spncci::MatrixType> eigenvectors;  // map: J -> eigenvectors
    std::cout<<"solving Hamiltonian"<<std::endl;
    for (const HalfInt J : run_parameters.J_values)
      spncci::SolveHamiltonian(observable_matrices[0].at(std::make_pair(J,J)),J,
        run_parameters.num_eigenvalues,
        run_parameters.eigensolver_num_convergence,  // whatever exactly this is...
        run_parameters.eigensolver_max_iterations,
        run_parameters.eigensolver_tolerance,
        eigenvalues, eigenvectors
        );


  }



}
