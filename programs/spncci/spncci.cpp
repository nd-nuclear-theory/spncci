/****************************************************************
  spncci.cpp

  Tests of explicit SpNCCI basis construction in LSU3Shell basis.

  This code just tests normalization, but using clean refactored
  infrastructure.  Other deeper tests (of unit tensor matrix elements)
  were carried out in compute_unit_tensor_rmes.cpp.

  Required data:

  * Relative operator lsu3shell rme input files are generated by

      generate_lsu3shell_relative_operators.cpp

    which is invoked through scripting in

      compute_relative_tensors_lsu3shell_rmes.py

    Example: Z=3 N=3 twice_Nsigma0=22 Nmax=2 Nstep=2 N1v[=N1b]=1
   
    % python3 script/compute_relative_tensors_lsu3shell_rmes.py 3 3 22 2 2 1

    Only need .rme and .dat files.

    Not saved to repository since ~3.5 Mb...

       data/lsu3shell/lsu3shell_rme_6Li_Nmax02
    
       * Relative Hamiltonian (and observable) upcoupled rme files are
    generated by

      generate_relative_u3st_operators

    which is invoked manually for now as

      generate_relative_u3st_operators A Nmax N1v basename

   Example:

       ../operators/generate_relative_u3st_operators 6 2 1 hamiltonian

       with hamiltonian.load containing

       20    // hw
       Tintr 1.0    // coef
       INT 1.0 4 0 0 0 relative_observables/JISP16_Nmax20_hw20.0_rel.dat      // coef Jmax J0 T0 g0 interaction_filename

       ../operators/generate_relative_u3st_operators 6 2 1 Nintr

       with Nintr.load containing

       20    // hw
       Nintr 1.0    // coef

       ../operators/generate_relative_u3st_operators 6 2 1 r2intr

       with r2intr.load containing

       20    // hw
       r2intr 1.0    // coef

   % ln -s ../../data/relative_observables/

         
     

  Anna E. McCoy and Mark A. Caprio
  University of Notre Dame

  2/20/17 (mac): Created (starting from explicit.cpp).
  4/9/17 (aem): Incorporated baby spncci hypersectors
  6/5/17 (mac): Read relative rather than intrinsic symplectic operators.
  6/16/17 (aem) : offload to computation and io control
****************************************************************/

#include <cstdio>
#include <ctime>
#include <fstream>
#include <sys/resource.h>
#include <omp.h>  

#include "SymEigsSolver.h"  // from spectra
#include "cppformat/format.h"

#include "lgi/lgi_solver.h"
// to vett as moved into computation_control 
#include "mcutils/eigen.h"
#include "mcutils/parsing.h"
#include "mcutils/profiling.h"
#include "spncci/branching.h"
#include "spncci/computation_control.h"
#include "spncci/decomposition.h"
#include "spncci/eigenproblem.h"
#include "spncci/parameters.h"
#include "spncci/results_output.h"

////////////////////////////////////////////////////////////////
// WIP code
//
// to extract to spncci library when ready
////////////////////////////////////////////////////////////////
  
namespace spncci
{

  void InitializeSectorsSpU3S(
      const spncci::SpaceSpU3S& space_spu3s, int num_observables, 
      const std::vector<double>& hw_values,
      std::vector<std::vector<spncci::SectorLabelsSpU3S>>& observables_sectors_spu3s,
      std::vector<std::vector<basis::OperatorBlocks<double>>>& observables_blocks_spu3s,
      const std::vector<std::vector<u3shell::IndexedOperatorLabelsU3S>>& observable_symmetries_u3s
    )
  // NO! THIS IS NOT THE ONE YOU WANT TO BE EDITING!  YOU ARE LOOKING FOR InitializeSectorsU3S BELOW!
  {
    // enumerate u3S space from baby spncci for each observable 
    // spncci::SpaceU3S space_u3s(baby_spncci_space);

    // vector of sectors for each observable
    observables_sectors_spu3s.resize(num_observables);
  
    // vector of blocks for u3 sectors for each hbar omega,for each observable
    observables_blocks_spu3s.resize(hw_values.size());

    // for each observable, enumerate sectors
    int total_entries = 0;  // total across observables, but not across hw
    int max_sector_entries = 0;
    int max_observable_entries = 0;
    for(int observable_index=0; observable_index<num_observables; ++observable_index) 
      {
        std::vector<spncci::SectorLabelsSpU3S>& sectors_spu3s=observables_sectors_spu3s[observable_index];
        spncci::GetSectorsSpU3S(space_spu3s,observable_symmetries_u3s[observable_index],sectors_spu3s);


        // do counting for this observable
        int observable_entries = 0;
        for(int sector_index=0; sector_index<sectors_spu3s.size(); ++sector_index)
          {
            int rows=space_spu3s.GetSubspace(sectors_spu3s[sector_index].bra_index()).full_dimension();
            int cols=space_spu3s.GetSubspace(sectors_spu3s[sector_index].ket_index()).full_dimension();
            int sector_entries = rows*cols;
            max_sector_entries = std::max(max_sector_entries,sector_entries);
            observable_entries += sector_entries;
          }

        // accumulate counting from this observable
        max_observable_entries = std::max(max_observable_entries,observable_entries);
        total_entries += observable_entries;
      }

    // For each hbar omega, zero initialize block for each observable
    // based on basis::SetOperatorToZero in operator.h
    for(int hw_index=0; hw_index<hw_values.size(); ++hw_index)
      {
        std::vector<basis::OperatorBlocks<double>>& observables_blocks=observables_blocks_spu3s[hw_index];
        observables_blocks.resize(num_observables);

        for(int observable_index=0; observable_index<num_observables; ++observable_index)
          {
            basis::OperatorBlocks<double>& blocks=observables_blocks[observable_index];
            std::vector<spncci::SectorLabelsSpU3S>& sectors_spu3s=observables_sectors_spu3s[observable_index];
            blocks.resize(sectors_spu3s.size());

            for(int sector_index=0; sector_index<sectors_spu3s.size(); ++sector_index)
              {
                int rows=space_spu3s.GetSubspace(sectors_spu3s[sector_index].bra_index()).full_dimension();
                int cols=space_spu3s.GetSubspace(sectors_spu3s[sector_index].ket_index()).full_dimension();
                blocks[sector_index]=basis::OperatorBlock<double>::Zero(rows,cols);
              }
          }

      } 
  }

  void InitializeU3SSectors(
      const spncci::SpaceU3S& space_u3s,
      int num_observables, 
      const std::vector<std::vector<u3shell::IndexedOperatorLabelsU3S>>& observable_symmetries_u3s,
      std::vector<std::vector<spncci::SectorLabelsU3S>>& observables_sectors_u3s
    )
  {
    // vector of sectors for each observable
    observables_sectors_u3s.resize(num_observables);

    // for each observable, enumerate sectors 
    for(int observable_index=0; observable_index<num_observables; ++observable_index) 
      {
        std::vector<spncci::SectorLabelsU3S>& sectors_u3s=observables_sectors_u3s[observable_index];
        spncci::GetSectorsU3S(space_u3s,observable_symmetries_u3s[observable_index],sectors_u3s);
      }
  }

  void WriteU3SSectorInformation(
      std::ostream& out_stream,
      const spncci::SpaceU3S& space_u3s,
      int num_observables, 
      const std::vector<std::vector<spncci::SectorLabelsU3S>>& observables_sectors_u3s
    )
  {

    StartNewSection(out_stream,"U3S sector dimensions");
    out_stream
      << "# observable_index num_sectors max_sector_entries observable_entries"
      << std::endl;

    // for each observable, enumerate sectors 
    int total_entries = 0;  // total across observables, but not across hw
    int max_sector_entries = 0;
    int max_observable_entries = 0;
    for(int observable_index=0; observable_index<num_observables; ++observable_index) 
      {
        const std::vector<spncci::SectorLabelsU3S>& sectors_u3s=observables_sectors_u3s[observable_index];

        // do counting for this observable
        int observable_entries = 0;
        for(int sector_index=0; sector_index<sectors_u3s.size(); ++sector_index)
          {
            int rows=space_u3s.GetSubspace(sectors_u3s[sector_index].bra_index()).full_dimension();
            int cols=space_u3s.GetSubspace(sectors_u3s[sector_index].ket_index()).full_dimension();
            int sector_entries = rows*cols;
            max_sector_entries = std::max(max_sector_entries,sector_entries);
            observable_entries += sector_entries;
          }

        // write statistics for this observable
        out_stream
          << fmt::format(
              "{:2d} {:5d} {:10d} {:10d}",
              observable_index,sectors_u3s.size(),max_sector_entries,observable_entries
            )
          << std::endl;


        // accumulate counting from this observable -- totals across observables are not currently output
        max_observable_entries = std::max(max_observable_entries,observable_entries);
        total_entries += observable_entries;
      }
  }

  void InitializeU3SBlocks(
      const spncci::SpaceU3S& space_u3s,
      int num_observables, 
      const std::vector<double>& hw_values,
      const std::vector<std::vector<spncci::SectorLabelsU3S>>& observables_sectors_u3s,
      std::vector<std::vector<spncci::OperatorBlocks>>& observables_blocks_u3s
    )
  {
    // vector of blocks for u3 sectors for each hbar omega,for each observable
    observables_blocks_u3s.resize(hw_values.size());

    // For each hbar omega, zero initialize block for each observable
    // based on basis::SetOperatorToZero in operator.h
    // int total_entries = 0;
    for(int hw_index=0; hw_index<hw_values.size(); ++hw_index)
      {
        std::vector<spncci::OperatorBlocks>& observables_blocks=observables_blocks_u3s[hw_index];
        observables_blocks.resize(num_observables);

        for(int observable_index=0; observable_index<num_observables; ++observable_index)
          {
            // Note: this would all be a one-liner call to basis::SetOperatorToZero,
            // if sectors_u3s were a proper Sectors object
            spncci::OperatorBlocks& blocks=observables_blocks[observable_index];
            const std::vector<spncci::SectorLabelsU3S>& sectors_u3s=observables_sectors_u3s[observable_index];
            blocks.resize(sectors_u3s.size());
            for(int sector_index=0; sector_index<sectors_u3s.size(); ++sector_index)
              {
                int rows=space_u3s.GetSubspace(sectors_u3s[sector_index].bra_index()).full_dimension();
                int cols=space_u3s.GetSubspace(sectors_u3s[sector_index].ket_index()).full_dimension();
                blocks[sector_index]=spncci::OperatorBlock::Zero(rows,cols);
              }

            // // tally allocated matrix elements
            // int entries = basis::AllocatedEntries(blocks);
            // total_entries += entries;
            // std::cout
            //   << fmt::format(
            //       "  hw_index {:2d} observable_index {:2d} sectors {:4d} entries {:d} = {:e}",
            //       hw_index,observable_index,sectors_u3s.size(),entries,double(entries)
            //     )
            //   << std::endl;
          }

      } 
  }


  void PrintHypersectors(
      const spncci::BabySpNCCISpace& baby_spncci_space,
      const u3shell::RelativeUnitTensorSpaceU3S& unit_tensor_space,
      const spncci::BabySpNCCIHypersectors& baby_spncci_hypersectors,
      const basis::OperatorHyperblocks<double>& unit_tensor_hyperblocks
    )
  {
    for(int hypersector_index=0; hypersector_index<baby_spncci_hypersectors.size(); ++hypersector_index)
      {
        const auto& hypersector=baby_spncci_hypersectors.GetHypersector(hypersector_index);
    
        int unit_tensor_subspace_index, ket_subspace_index,bra_subspace_index, rho0;
        std::tie(bra_subspace_index, ket_subspace_index,unit_tensor_subspace_index,rho0)=hypersector.Key();

        const auto& unit_tensor_subspace=unit_tensor_space.GetSubspace(unit_tensor_subspace_index);
        const auto& bra_subspace=baby_spncci_space.GetSubspace(bra_subspace_index);
        const auto& ket_subspace=baby_spncci_space.GetSubspace(ket_subspace_index);

        // std::cout<<"hypersector "<<hypersector_index<<" "<< bra_subspace.LabelStr()<<"  "<<ket_subspace.LabelStr()
        // <<"  "<<unit_tensor_subspace.LabelStr()<<rho0<<std::endl;
        // for(int i=0; i<unit_tensor_subspace.size(); ++i)
        // {
        //   int T0,Sp,Tp,S,T;
        //   std::tie(T0,Sp,Tp,S,T)=unit_tensor_subspace.GetStateLabels(i);
        //   std::cout<<fmt::format("{}  {} {}  {} {}",T0,Sp,Tp,S,T)<<std::endl;
        //   std::cout<<unit_tensor_hyperblocks[hypersector_index][i]<<std::endl<<std::endl;
        // }
      }

  }

  void PrintU3SSector(
      const std::vector<double>& hw_values,
      const std::vector<std::vector<spncci::SectorLabelsU3S>>& observables_sectors_u3s,
      std::vector<std::vector<spncci::OperatorBlocks>>& observables_blocks_u3s, //can't be constant because of chop function
      const spncci::SpaceU3S& space_u3s,
      int num_observables
    )
  // Prints out U3SSectors and blocks 
  {
    for(int observable_index=0; observable_index<num_observables; ++observable_index)
      for(int hw_index=0; hw_index<hw_values.size(); ++hw_index)
        {
          std::cout<<"observable "<<observable_index<<" hw "<<hw_values[hw_index]<<std::endl;
          const std::vector<spncci::SectorLabelsU3S>& sectors_u3s=observables_sectors_u3s[observable_index];
          spncci::OperatorBlocks& blocks_u3s=observables_blocks_u3s[hw_index][observable_index];
          for(int i=0; i<blocks_u3s.size(); ++i)
            {
              auto& block=blocks_u3s[i];
              const auto& sector=sectors_u3s[i];            
              const auto& bra=space_u3s.GetSubspace(sector.bra_index());
              const auto& ket=space_u3s.GetSubspace(sector.ket_index());
              const auto& op=sector.operator_labels();
              if(not mcutils::IsZero(block))
                {
                  std::cout<<"block number "<<i<<std::endl;
                  std::cout<<bra.Str()<<"  "<<ket.Str()<<"  "<<op.Str()<<"  "<<sector.kappa0()<<"  "<<sector.L0()<<"  "<<sector.rho0()<<std::endl;
                  mcutils::ChopMatrix(block, 1e-6);
                  std::cout<<block<<std::endl<<std::endl;
                }
            }
        }
  }


}// end namespace

////////////////////////////////////////////////////////////////
// main body
////////////////////////////////////////////////////////////////

int main(int argc, char **argv)
{
  std::cout<<"entering spncci"<<std::endl;
  ////////////////////////////////////////////////////////////////
  // initialization
  ////////////////////////////////////////////////////////////////
  
  // SU(3) caching
  u3::U3CoefInit();
  u3::UCoefCache u_coef_cache;
  u3::PhiCoefCache phi_coef_cache;
  u3::g_u_cache_enabled = true;

  // parameters for certain calculations
  spncci::g_zero_tolerance = 1e-6;
  spncci::g_suppress_zero_sectors = true;


  // Default binary mode, unless environment variable SPNCCI_RME_MODE
  // set to "text".
  //
  // This is meant as an ad hoc interface until text mode i/o is abolished.
  lsu3shell::g_rme_binary_format = true;
  char* spncci_rme_mode_cstr = std::getenv("SPNCCI_RME_MODE");
  if (spncci_rme_mode_cstr!=NULL)
    {
      const std::string spncci_rme_mode = std::getenv("SPNCCI_RME_MODE");
      if (spncci_rme_mode=="text")
        lsu3shell::g_rme_binary_format = false;
    }

  // run parameters
  std::cout << "Reading control file..." << std::endl;
  spncci::RunParameters run_parameters;

  // Eigen OpenMP multithreading mode
  Eigen::initParallel();
  // Eigen::setNbThreads(0);

  // open output files
  std::ofstream results_stream("spncci.res");

  // results output: code information
  spncci::StartNewSection(results_stream,"CODE");
  spncci::WriteCodeInformation(results_stream,run_parameters);

  // results output: run parameters
  spncci::StartNewSection(results_stream,"PARAMETERS");
  spncci::WriteRunParameters(results_stream,run_parameters);

  std::cout<<"Nmax="<<run_parameters.Nmax<<std::endl;

  ////////////////////////////////////////////////////////////////
  // read lsu3shell basis
  ////////////////////////////////////////////////////////////////

  std::cout << "Read lsu3shell basis..." << std::endl;
  // read lsu3shell basis (regroup into U3SPN subspaces)
  lsu3shell::LSU3BasisTable lsu3shell_basis_table;
  lsu3shell::U3SPNBasisLSU3Labels lsu3shell_basis_provenance;
  u3shell::SpaceU3SPN lsu3shell_space;
  lsu3shell::ReadLSU3Basis(
      run_parameters.Nsigma0,run_parameters.lsu3shell_basis_filename,
      lsu3shell_basis_table,lsu3shell_basis_provenance,lsu3shell_space
    );

  ////////////////////////////////////////////////////////////////
  // solve for LGIs
  ////////////////////////////////////////////////////////////////
  std::cout << "Solve for LGIs..." << std::endl;

  // timing start
  mcutils::Timer timer_lgi;

  lgi::MultiplicityTaggedLGIVector lgi_families;
  basis::MatrixVector lgi_expansions;
  
  spncci::GetLGIExpansion(
      lsu3shell_space,lsu3shell_basis_table,
      run_parameters.Brel_filename,run_parameters.Nrel_filename,
      run_parameters.A, run_parameters.Nsigma0,
      lgi_families, lgi_expansions
    );

  // diagnostics
  std::cout << fmt::format("  LGI families {}",lgi_families.size()) << std::endl;
  if (false)
    lgi::WriteLGILabels(lgi_families,std::cout);

  // timing stop
  timer_lgi.Stop();
  std::cout << fmt::format("(Task time: {})",timer_lgi.ElapsedTime()) << std::endl;

  /////////////////////////////////////////////////////////////////////////////////////
  // set up SpNCCI space
  ////////////////////////////////////////////////////////////////

  std::cout << "Set up SpNCCI space..." << std::endl;

  // build SpNCCI irrep branchings
  spncci::SpNCCISpace spncci_space;
  spncci::SigmaIrrepMap sigma_irrep_map;  // persistent container to store branchings
  spncci::NmaxTruncator truncator(run_parameters.Nsigma0,run_parameters.Nmax);
  bool restrict_sp3r_to_u3_branching=false;
  if(run_parameters.A<6)
    restrict_sp3r_to_u3_branching=true;

  spncci::GenerateSpNCCISpace(lgi_families,truncator,spncci_space,sigma_irrep_map,restrict_sp3r_to_u3_branching);

  // for(int i=0; i<spncci_space.size(); ++i)
  //   std::cout<<i<<"  "<<spncci_space[i].Str()<<spncci_space[i].gamma_max()<<std::endl;

  // diagnostics
  std::cout << fmt::format("  Irrep families {}",spncci_space.size()) << std::endl;
  std::cout << fmt::format("  TotalU3Subspaces {}",spncci::TotalU3Subspaces(spncci_space)) << std::endl;
  std::cout << fmt::format("  TotalDimensionU3S {}",spncci::TotalDimensionU3S(spncci_space)) << std::endl;

  // build baby spncci space 
  spncci::BabySpNCCISpace baby_spncci_space(spncci_space);

  // build SpU3S gathered space
  std::cout << "Build SpU3S space..." << std::endl;
  spncci::SpaceSpU3S spu3s_space(baby_spncci_space);
  std::cout
    << fmt::format("  subspaces {} dimension {} full_dimension {}",
                   spu3s_space.size(),spu3s_space.Dimension(),spu3s_space.FullDimension()
      )
    << std::endl;
  std::cout
    << fmt::format("  compare... TotalDimensionU3S {}",
                   TotalDimensionU3S(spncci_space)
      )
    << std::endl;
  // std::cout << spu3s_space.DebugStr(true);

  // build SpLS branched space
  std::cout << "Build SpLS space..." << std::endl;
  spncci::SpaceSpLS spls_space(spu3s_space);
  std::cout
    << fmt::format("  subspaces {} dimension {} full_dimension {}",
                   spls_space.size(),spls_space.Dimension(),spls_space.FullDimension()
      )
    << std::endl;
  std::cout
    << fmt::format("  compare... TotalDimensionU3LS {}",TotalDimensionU3LS(spncci_space))
    << std::endl;
  // std::cout << splss_space.DebugStr(true);

  // build SpJ branched space
  std::cout << "Build SpJ space..." << std::endl;
  spncci::SpaceSpJ spj_space(run_parameters.J_values,spls_space);
  std::cout
    << spj_space.DebugStr(false)
    << std::endl;
  std::cout
    << fmt::format("  subspaces {}",spj_space.size())
    << std::endl;


  // results output: basis information
  spncci::StartNewSection(results_stream,"BASIS");
  spncci::WriteBasisStatistics(results_stream,spncci_space,baby_spncci_space,spu3s_space,spls_space,spj_space);
  spncci::WriteSpU3SSubspaceListing(results_stream,baby_spncci_space,run_parameters.Nsigma0);
  spncci::WriteBabySpNCCISubspaceListing(results_stream,baby_spncci_space,run_parameters.Nsigma0);

  ///////////////////////////////////////////////////////////////////////////////////////////////////
  // Enumerate unit tensor space 
  ///////////////////////////////////////////////////////////////////////////////////////////////////
  int J0_for_unit_tensors = -1;  // all J0
  int T0_for_unit_tensors = -1;  // all T0
  const bool restrict_positive_N0 = false;  // don't restrict to N0 positive

  // get full set of possible unit tensor labels up to Nmax, N1v truncation
  std::vector<u3shell::RelativeUnitTensorLabelsU3ST> unit_tensor_labels;  
  u3shell::GenerateRelativeUnitTensorLabelsU3ST(
      run_parameters.Nmax, run_parameters.N1v,
      unit_tensor_labels,J0_for_unit_tensors,T0_for_unit_tensors,
      restrict_positive_N0
    );

  // for(auto tensor :unit_tensor_labels)
  //   std::cout<<tensor.Str()<<std::endl;

  // generate unit tensor subspaces 
  u3shell::RelativeUnitTensorSpaceU3S 
    unit_tensor_space(run_parameters.Nmax,run_parameters.N1v,unit_tensor_labels);

  ///////////////////////////////////////////////////////////////////////////////////////////////////
  //  Read in observables  
  ///////////////////////////////////////////////////////////////////////////////////////////////////        

  std::cout << "Reading observables..." << std::endl;

  // Initialize containers for rmes and their symmetries 
  // Stored by hw, then by observable
  std::vector<std::vector<u3shell::RelativeRMEsU3SSubspaces>> observables_relative_rmes(run_parameters.hw_values.size());
  std::vector<std::vector<u3shell::IndexedOperatorLabelsU3S>> observable_symmetries_u3s(run_parameters.num_observables); 

  spncci::ReadRelativeObservables(
      run_parameters.Nmax, run_parameters.N1v, run_parameters.hw_values,
      run_parameters.observable_directory,run_parameters.observable_filenames, 
      unit_tensor_space, observables_relative_rmes, observable_symmetries_u3s
    );

  ////////////////////////////////////////////////////////////////
  // Enumerate U3S sectors for observables 
  ////////////////////////////////////////////////////////////////

  std::cout << "Enumerating u3s sectors..." << std::endl;

  // enumerate u3S space from baby spncci for each observable 
  spncci::SpaceU3S space_u3s(baby_spncci_space);

  // vector of sectors for each observable
  std::vector<std::vector<spncci::SectorLabelsU3S>> observables_sectors_u3s;//(run_parameters.num_observables);
  
  // vector of blocks for u3 sectors for each hbar omega,for each observable
  std::vector<std::vector<spncci::OperatorBlocks>> observables_blocks_u3s;//(run_parameters.hw_values.size());


  spncci::InitializeU3SSectors(
      space_u3s,
      run_parameters.num_observables, 
      observable_symmetries_u3s,
      observables_sectors_u3s
    );
  spncci::WriteU3SSectorInformation(
      results_stream, 
      space_u3s,
      run_parameters.num_observables, 
      observables_sectors_u3s
    );


  ////////////////////////////////////////////////////////////////
  // terminate counting only run
  ////////////////////////////////////////////////////////////////

  // We now have to do all termination manually.  But, when the
  // control code is properly refactored, we can just have a single
  // termination, and the rest of the run can be in an "if
  // (!count_only)"...

  if (run_parameters.count_only)
    {

      // termination
      results_stream.close();

      std::cout << "End of counting-only run" << std::endl;
      std::exit(EXIT_SUCCESS);
    }


  ////////////////////////////////////////////////////////////////
  // Allocate U3S sectors for observables 
  ////////////////////////////////////////////////////////////////

  std::cout << "Allocating u3s blocks..." << std::endl;

  spncci::InitializeU3SBlocks(
      space_u3s,
      run_parameters.num_observables, 
      run_parameters.hw_values,
      observables_sectors_u3s,
      observables_blocks_u3s
    );


  ////////////////////////////////////////////////////////////////
  // precompute K matrices
  ////////////////////////////////////////////////////////////////
  std::cout << "Precompute K matrices..." << std::endl;

  // timing start
  mcutils::Timer timer_k_matrices;

  // traverse distinct sigma values in SpNCCI space, generating K
  // matrices for each
  spncci::KMatrixCache k_matrix_cache;
  spncci::PrecomputeKMatrices(sigma_irrep_map,k_matrix_cache);

  // timing stop
  timer_k_matrices.Stop();
  std::cout << fmt::format("(Task time: {})",timer_k_matrices.ElapsedTime()) << std::endl;

  // std::cout<<"Kmatrices "<<std::endl;
  // for(auto it=k_matrix_cache.begin(); it!=k_matrix_cache.end(); ++it)
  //   {
  //     std::cout<<"sigma "<<it->first.Str()<<std::endl;
  //     for(auto it2=it->second.begin();  it2!=it->second.end(); ++it2)
  //     {
  //       std::cout<<"  omega"<<it2->first.Str()<<std::endl;
  //       auto matrix=it2->second;
  //       std::cout<<matrix<<std::endl;
  //       std::cout<<matrix.inverse()<<std::endl;
  //     }
  //   }

  // ///////////////////////////////////////////////////////////////////////////////////////////////////
  // //  For testing, get lsu3shell expansion of full spncci basis
  // ///////////////////////////////////////////////////////////////////////////////////////////////////        
  /////////////////////////////////////////////////////////////////////////////////////
  // // For explicit construction 
  // u3shell::SectorsU3SPN Aintr_sectors;
  // basis::MatrixVector Aintr_matrices;
  // spncci::ReadLSU3ShellSymplecticRaisingOperatorRMEs(
  //     lsu3shell_basis_table,lsu3shell_space, 
  //     run_parameters.Arel_filename,Aintr_sectors,Aintr_matrices,
  //     run_parameters.A
  //   );

  // if(run_parameters.Nmax==run_parameters.Nsigmamax)
  // {
  // basis::MatrixVector spncci_expansions;
  // spncci::ConstructSpNCCIBasisExplicit(
  //     lsu3shell_space,spncci_space,lgi_expansions,baby_spncci_space,
  //     k_matrix_cache,Aintr_sectors,Aintr_matrices,spncci_expansions
  //   );
  // }

  ///////////////////////////////////////////////////////////////////////////////////////////////
  std::cout<<"setting up lgi unit tensor blocks"<<std::endl;
  
  // map of {lgi pair : list of hypersector indices organized by Nsum}
  // Read in lsu3shell unit tensors
  // transform block for each unit tensor to spncci
  // identify unit tensors with non-zero rmes's between each lgi pair 
  // Generate unit tensor labels for recurrence for each lgi pair
  // put seed blocks into hypersector blocks for each lgi pair 

  // Get list of unit tensor labels between lgi's 
  std::vector<u3shell::RelativeUnitTensorLabelsU3ST> lgi_unit_tensor_labels;
  u3shell::GenerateRelativeUnitTensorLabelsU3ST(
      run_parameters.Nsigmamax, run_parameters.N1v,
      lgi_unit_tensor_labels,J0_for_unit_tensors,T0_for_unit_tensors,
      restrict_positive_N0
    );

  //////////////////////////////////////////////////////////////////////////////////////////
  // for each unit tensor, read in unit tensor lsu3shell rmes and transform to spncci basis
  //////////////////////////////////////////////////////////////////////////////////////////
  // timing start
  mcutils::Timer timer_read_seeds;

  std::cout << "Get seed unit tensor rmes..." << std::endl;
  // diagnostic
  std::cout << fmt::format("  seed unit tensors {}",lgi_unit_tensor_labels.size()) << std::endl;
  
  // Container for lgi unit tensor blocks 
  std::map< std::pair<int,int>, std::map<std::pair<int,int>, basis::OperatorBlocks<double>>> lgi_unit_tensor_blocks;
  
  // Get unit tensor seeds obtained from lsu3shell rmes transformed to spncci basis.
  spncci::GetUnitTensorSeedBlocks(
      lgi_unit_tensor_labels,unit_tensor_space,
      run_parameters.relative_unit_tensor_filename_template,
      lsu3shell_space, lsu3shell_basis_table,
      lgi_expansions, baby_spncci_space,
      lgi_unit_tensor_blocks
    );

  timer_read_seeds.Stop();
  std::cout << fmt::format("(Task time: {})",timer_read_seeds.ElapsedTime()) << std::endl;

  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  //create a map of vectors of unit tensor subspace indices keyed by spncci irrep pairs 
  std::map<std::pair<int,int>,std::set<int>>lgi_unit_tensor_subset;
  for(auto it=lgi_unit_tensor_blocks.begin(); it!=lgi_unit_tensor_blocks.end(); ++it)
    for(auto it2=it->second.begin(); it2!=it->second.end(); ++it2)
      lgi_unit_tensor_subset[it->first].insert(it2->first.first);
  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // for each lgi pair lgi1, lgi2 compute all unit tensor hypersectors for which Nnp<=Nn and 
  // the conjugate hypersectors for Nnp>Nn, i.e., compute <lgi1 Nnp=0 | |lgi2 Nn=2> and 
  // <lgi2 Nn=0| |lgi1 Nnp=2> etc. 

  // timing start
  std::cout<<"Starting recurrence and contraction"<<std::endl;
  mcutils::Timer timer_recurrence;


  // Nested parallel regions (region 1 is lgi pairs, region 2 is recurrence.   )

  // Need to add seeds for both lgi pair and conjugate lgi pair

  // // if nested parallel
  // num_lgi_pair=lgi_unit_tensor_blocks.size()
  // int chunk_size=30;
  int total_num_threads;
#pragma omp parallel 
  {
    total_num_threads=omp_get_num_threads();
  }
  
  int num_threads_outer_loop;
  if(run_parameters.Nmax>run_parameters.Nsigmamax+2)
    num_threads_outer_loop=int(sqrt(total_num_threads));
  else
    num_threads_outer_loop=total_num_threads;
  
  // int num_threads_outer_loop=total_num_threads/num_threads_inner_loop;
  int num_threads_inner_loop=total_num_threads/num_threads_outer_loop;
  // std::cout<<"total "<<total_num_threads<<" "<<num_threads_outer_loop<<"  "<<num_threads_inner_loop<<std::endl;
  // num_outerloop_threads=min(num_threads,num_lgi_pair/2/chunk_size);
  // num_innerloop_threads=num_threads/num_outerloop_threads;
  //
  // Will need to pass optional parameter to recurrence

  // Parallel region?

  std::map<std::pair<int,int>, 
           std::map<std::pair<int,int>,basis::OperatorBlocks<double>>
           >::iterator it;
  std::vector<
    std::map<std::pair<int,int>, 
             std::map<std::pair<int,int>,basis::OperatorBlocks<double>>
             >::iterator
    > iterators;
  for(it=lgi_unit_tensor_blocks.begin(); it!=lgi_unit_tensor_blocks.end(); ++it)
    iterators.push_back(it);


#pragma omp parallel  num_threads(num_threads_outer_loop)
  {
    // #pragma omp single
    // std::cout << "omp_get_num_threads " << omp_get_num_threads() << std::endl;

#pragma omp for schedule(dynamic)
    for(int i=0; i<lgi_unit_tensor_blocks.size(); ++i)
      // for(it=lgi_unit_tensor_blocks.begin(); it!=lgi_unit_tensor_blocks.end(); ++it)
      {
        it=iterators[i];
        int irrep_family_index_bra,irrep_family_index_ket;
        std::tie(irrep_family_index_bra,irrep_family_index_ket)=it->first;
      
        if(irrep_family_index_bra>irrep_family_index_ket)
          continue;      

        // Generate hypersectors for recurrence 
        std::vector<std::vector<int>> unit_tensor_hypersector_subsets;
        spncci::BabySpNCCIHypersectors baby_spncci_hypersectors;
        spncci::GenerateRecurrenceHypersectors(
            unit_tensor_space,baby_spncci_space,lgi_unit_tensor_subset,
            run_parameters.Nmax, irrep_family_index_bra, irrep_family_index_ket,
            unit_tensor_hypersector_subsets,
            baby_spncci_hypersectors
          );

        // std::cout<<"number of hypersectors "<<baby_spncci_hypersectors.size()<<std::endl;

        // // std::cout<<"checking hypersector subsets"<<std::endl;
        // for(int N=0; N<unit_tensor_hypersector_subsets.size(); N++)
        //   for(int hypersector_index : unit_tensor_hypersector_subsets[N])
        //     {
        //       // std::cout<<"N="<<N<<std::endl;
        //       const auto& hypersector=baby_spncci_hypersectors.GetHypersector(hypersector_index);
        //       int unit_tensor_subspace_index, ket_subspace_index,bra_subspace_index, rho0;
        //       std::tie(bra_subspace_index, ket_subspace_index,unit_tensor_subspace_index,rho0)=hypersector.Key();
    
        //       const auto& unit_tensor_subspace=unit_tensor_space.GetSubspace(unit_tensor_subspace_index);
        //       const auto& bra_subspace=baby_spncci_space.GetSubspace(bra_subspace_index);
        //       const auto& ket_subspace=baby_spncci_space.GetSubspace(ket_subspace_index);

        //       // std::cout<<"hypersector "<<hypersector_index<<" "<< bra_subspace.LabelStr()<<"  "<<ket_subspace.LabelStr()
        //       // <<"  "<<unit_tensor_subspace.LabelStr()<<rho0<<std::endl;

        //     }

        // zero initialize hypersectors 
        basis::OperatorHyperblocks<double> unit_tensor_hyperblocks;
        basis::SetHyperoperatorToZero(baby_spncci_hypersectors,unit_tensor_hyperblocks);


        // For testing with explicit construction
        // TODO: extract into separate loop
        // if(run_parameters.Nmax==run_parameters.Nsigmamax)
        // {
        //   basis::OperatorHyperblocks<double> unit_tensor_hyperblocks_explicit;
        // basis::SetHyperoperatorToZero(baby_spncci_hypersectors,unit_tensor_hyperblocks_explicit);
        // }
        ///////////////////////////////////////////////////////////////////////////////////////////////
      
        // Populate hypersectors with seeds
        spncci::PopulateHypersectorsWithSeeds(
            irrep_family_index_bra, irrep_family_index_ket,
            unit_tensor_hypersector_subsets[0],
            baby_spncci_space,baby_spncci_hypersectors, 
            lgi_unit_tensor_blocks,unit_tensor_hyperblocks
          );


        // Recurse over unit tensor hypersectors 
        // std::cout<<"entering the recurrence for "<<irrep_family_index_bra<<" "<<irrep_family_index_ket<<std::endl;

        spncci::ComputeUnitTensorHyperblocks(
            run_parameters.Nmax,run_parameters.N1v,u_coef_cache,phi_coef_cache,k_matrix_cache,
            spncci_space,baby_spncci_space,unit_tensor_space,
            baby_spncci_hypersectors, unit_tensor_hypersector_subsets,
            unit_tensor_hyperblocks,
            num_threads_inner_loop
          );

        // std::cout<<"checking hypersectors"<<std::endl;

        // spncci::PrintHypersectors(
        //   baby_spncci_space,unit_tensor_space, 
        //   baby_spncci_hypersectors,unit_tensor_hyperblocks
        //   );

        // spncci::CheckUnitTensorRecurrence(
        //   irrep_family_index_bra, irrep_family_index_ket,
        //   unit_tensor_space,lgi_unit_tensor_labels,
        //   run_parameters.relative_unit_tensor_filename_template,
        //   lsu3shell_space, lsu3shell_basis_table,
        //   spncci_space,baby_spncci_space,spncci_expansions,
        //   baby_spncci_hypersectors,unit_tensor_hyperblocks
        // );
      
        // std::cout<<"contracting over observables "<<std::endl;
        for(int observable_index=0; observable_index<run_parameters.num_observables; ++observable_index)
          for(int hw_index=0; hw_index<run_parameters.hw_values.size(); ++hw_index)
            {

              // std::cout<<"observable "<<observable_index<<" hw "<<run_parameters.hw_values[hw_index]<<std::endl;
              const u3shell::RelativeRMEsU3SSubspaces& relative_observable=observables_relative_rmes[hw_index][observable_index];
              const std::vector<spncci::SectorLabelsU3S>& sectors_u3s=observables_sectors_u3s[observable_index];
              spncci::OperatorBlocks& blocks_u3s=observables_blocks_u3s[hw_index][observable_index];
      

              // const std::vector<spncci::SectorLabelsSpU3S>& sectors_spu3s=observables_sectors_spu3s[observable_index];
              // basis::OperatorBlocks<double>& blocks_spu3s=observables_blocks_spu3s[hw_index][observable_index];

              ContractAndRegroupU3S(
                  unit_tensor_space,baby_spncci_space,
                  space_u3s,relative_observable,
                  baby_spncci_hypersectors,unit_tensor_hyperblocks,
                  sectors_u3s,blocks_u3s
                );


              // spncci::ContractAndRegroupSpU3S(
              //     unit_tensor_space, baby_spncci_space,
              //     spu3s_space,relative_observable,
              //     baby_spncci_hypersectors,unit_tensor_hyperblocks,
              //     sectors_spu3s,blocks_spu3s);

              // for(int i=0; i<blocks_u3s.size(); ++i)
              //   if(not mcutils::IsZero(blocks_u3s[i]-blocks_spu3s[i],1e-6))
              //   {
              //     std::cout<<"blocks "<<i<<" do not match"<<std::endl
              //     <<blocks_u3s[i]<<std::endl<<std::endl<<blocks_spu3s[i]<<std::endl<<std::endl; 
              //     assert(mcutils::IsZero(blocks_u3s[i]-blocks_spu3s[i]));
              //   }

            }
      }// end lgi_pair
  }//end parallel region

  // spncci::PrintU3SSector(
  //   run_parameters.hw_values,
  //   observables_sectors_u3s,observables_blocks_u3s,  
  //   space_u3s, run_parameters.num_observables
  // );

  timer_recurrence.Stop();
  
  std::cout << fmt::format("(Task time: {})",timer_recurrence.ElapsedTime()) << std::endl;

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // At this point observable rmes should be fully computed and unit tensor cache, Ucoef cache and Kmatrix cache deleted 
  // Delete Kmatrix
  // Delete Unit tensor Cache
  // Delete Ucoef Cache 
  //
  // Note: The clean way to do that is to encapsulate the unit tensor
  // setup phase of the code in a subroutine...  That breaks the
  // problem up into clean, structured subunits.  Anything that should
  // persist is clearly marked by the fact that it is passed in as a
  // reference.  And anything that is no longer needed automatically
  // gets destroyed as it goes out of scope.
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // loop over hw values, branch matrix sectors and compute eigenvalues
  
  ////////////////////////////////////////////////////////////////
  // set up indexing for branching
  ////////////////////////////////////////////////////////////////

  std::cout << "Set up basis indexing for branching..." << std::endl;

  // W coefficient cache -- needed for observable branching
  u3::WCoefCache w_cache;

  // determine J sectors for each observable
  std::vector<spncci::SectorsSpJ> observable_sectors;
  observable_sectors.resize(run_parameters.num_observables);
  for (int observable_index=0; observable_index<run_parameters.num_observables; ++observable_index)
    {
      const int J0=run_parameters.observable_J0_values[observable_index];
      observable_sectors[observable_index] = spncci::SectorsSpJ(spj_space,J0);
    }

  // set up basis indexing for branching
  std::map<HalfInt,spncci::SpaceLS> spaces_lsj;  // map: J -> space
  std::map<HalfInt,spncci::SpaceSpLS> spaces_splsj;
  for (const HalfInt J : run_parameters.J_values)
    {

      std::cout << fmt::format("Build LS space for J={}...",J.Str()) << std::endl;
      spaces_lsj[J] = spncci::SpaceLS(space_u3s,J);
      std::cout
        << fmt::format(
            "  subspaces {} dimension {}",
            J.Str(),
            spaces_lsj[J].size(),spaces_lsj[J].Dimension()
          ) << std::endl;

      // comparison tests with new basis branching construction
      std::cout << fmt::format("Build SpLS space for J={}...",J.Str()) << std::endl;
      spaces_splsj[J]=spncci::SpaceSpLS(spu3s_space,J);
      const auto& spls_space=spaces_splsj.at(J);
      // spncci::SpaceSpLS spls_space(spu3s_space,J);
      std::cout
        << fmt::format("  subspaces {} dimension {} full_dimension {}",
                       spls_space.size(),spls_space.Dimension(),spls_space.FullDimension()
          )
        << std::endl;
      std::cout
        << fmt::format("  compare... TotalDimensionU3LSJConstrained {}",TotalDimensionU3LSJConstrained(spncci_space,J))
        << std::endl;
    }


  ////////////////////////////////////////////////////////////////
  // calculation mesh master loop
  ////////////////////////////////////////////////////////////////


  std::cout << "Calculation mesh master loop..." << std::endl;

  // timing start
  mcutils::Timer timer_mesh;

  // for each hw value, solve eigen problem and get expectation values 
  for(int hw_index=0; hw_index<run_parameters.hw_values.size(); ++hw_index)
    {

      // retrieve mesh parameters
      double hw = run_parameters.hw_values[hw_index];
            
      // results output: log start of individual mesh calculation
      spncci::StartNewSection(results_stream,"RESULTS");
      spncci::WriteCalculationParameters(results_stream,hw);

      ////////////////////////////////////////////////////////////////
      // eigenproblem
      ////////////////////////////////////////////////////////////////

      std::cout<<"Solve eigenproblem..."<<std::endl;
      mcutils::Timer timer_eigenproblem;

      std::vector<spncci::Vector> eigenvalues;  // eigenvalues by J subspace
      std::vector<spncci::Matrix> eigenvectors;  // eigenvectors by J subspace
      eigenvalues.resize(spj_space.size());
      eigenvectors.resize(spj_space.size());
      for (int subspace_index=0; subspace_index<spj_space.size(); ++subspace_index)
        {
          HalfInt J = spj_space.GetSubspace(subspace_index).J();
          std::cout
            << fmt::format("J = {}",J)
            << std::endl;
          
          // branch Hamiltonian
          spncci::OperatorBlock hamiltonian_matrix;
          const int observable_index = 0;  // for Hamiltonian
          const int sector_index = subspace_index;  // for Hamiltonian (scalar)
          const int J0 = run_parameters.observable_J0_values[observable_index];
          assert(J0==0);
          spncci::ConstructBranchedBlock(
              w_cache,
              space_u3s,
              observables_sectors_u3s[observable_index],
              observables_blocks_u3s[hw_index][observable_index],
              spaces_lsj,
              J0,
              observable_sectors[observable_index].GetSector(sector_index),
              hamiltonian_matrix
            );

          std::cout
            << fmt::format("J = {}: {}x{}",J,hamiltonian_matrix.rows(),hamiltonian_matrix.cols())
            << std::endl;
          // std::cout<<hamiltonian_matrix<<std::endl<<std::endl;

          // solve eigenproblem
          spncci::Vector& eigenvalues_J = eigenvalues[subspace_index];
          spncci::Matrix& eigenvectors_J = eigenvectors[subspace_index];
          spncci::SolveHamiltonian(
              hamiltonian_matrix,
              J,
              run_parameters.num_eigenvalues,
              run_parameters.eigensolver_num_convergence,  // whatever exactly this is...
              run_parameters.eigensolver_max_iterations,
              run_parameters.eigensolver_tolerance,
              eigenvalues_J,eigenvectors_J
            );
        }

      // end timing
      timer_eigenproblem.Stop();
      std::cout << fmt::format("  (Eigenproblem: {})",timer_eigenproblem.ElapsedTime()) << std::endl;

      // results output: eigenvalues
      spncci::WriteEigenvalues(results_stream,spj_space,eigenvalues,run_parameters.gex);

      ////////////////////////////////////////////////////////////////
      // do decompositions
      ////////////////////////////////////////////////////////////////

      std::cout << "Calculate eigenstate decompositions..." << std::endl;
      mcutils::Timer timer_decompositions;

      // decomposition matrices:
      //   - vector over J subspace index
      //   - matrix over (basis_subspace_index,eigenstate_index)
      //
      // That is, decompositions are stored as column vectors, within a
      // matrix, much like the eigenstates themselves.
      std::vector<spncci::Matrix> Nex_decompositions;
      std::vector<spncci::Matrix> baby_spncci_decompositions;
      Nex_decompositions.resize(spj_space.size());
      baby_spncci_decompositions.resize(spj_space.size());

      // calculate decompositions
      spncci::CalculateNexDecompositions(
          spj_space,
          eigenvectors,
          Nex_decompositions,
          run_parameters.Nsigma0,run_parameters.Nmax
        );

      spncci::CalculateBabySpNCCIDecompositions(
          spj_space,
          eigenvectors,
          baby_spncci_decompositions,
          baby_spncci_space.size()
        );

      // end timing
      timer_decompositions.Stop();
      std::cout << fmt::format("  (Decompositions: {})",timer_decompositions.ElapsedTime()) << std::endl;

      // results output: decompositions
      spncci::WriteDecompositions(
          results_stream,
          "Nex",".6f",
          spj_space,
          Nex_decompositions,
          run_parameters.gex
        );

      spncci::WriteDecompositions(
          results_stream,
          "BabySpNCCI",".4e",
          spj_space,
          baby_spncci_decompositions,
          run_parameters.gex
        );


      ////////////////////////////////////////////////////////////////
      // calculate observable RMEs
      ////////////////////////////////////////////////////////////////

      std::cout << "Calculate observable results..." << std::endl;
      mcutils::Timer timer_observables;

      // observable_results_matrices:
      //   - vector over observable_index
      //   - vector over sector_index
      //   - matrix over (bra_eigenstate_index,ket_eigenstate_index)
      std::vector<spncci::OperatorBlocks> observable_results_matrices;
      observable_results_matrices.resize(run_parameters.num_observables);

      // calculate observable results
      for (int observable_index=0; observable_index<run_parameters.num_observables; ++observable_index)
        {

          // retrieve sectors
          const spncci::SectorsSpJ& sectors = observable_sectors[observable_index];

          // calculate observable on each sector
          observable_results_matrices[observable_index].resize(sectors.size());
          for (int sector_index=0; sector_index<sectors.size(); ++sector_index)
            {
            
              // retrieve sector information
              const spncci::SectorsSpJ::SectorType& sector = sectors.GetSector(sector_index);
              const int bra_subspace_index = sector.bra_subspace_index();
              const int ket_subspace_index = sector.ket_subspace_index();

              // branch observable block
              spncci::OperatorBlock observable_block;
              const int J0 = run_parameters.observable_J0_values[observable_index];  // well, J0 had better be 0!
              spncci::ConstructBranchedBlock(
                  w_cache,
                  space_u3s,
                  observables_sectors_u3s[observable_index],
                  observables_blocks_u3s[hw_index][observable_index],
                  spaces_lsj,
                  J0,
                  observable_sectors[observable_index].GetSector(sector_index),
                  observable_block
                );

              // calculate observable results
              Eigen::MatrixXd& observable_results_matrix = observable_results_matrices[observable_index][sector_index];
              observable_results_matrix = eigenvectors[bra_subspace_index].transpose()
                * observable_block
                * eigenvectors[ket_subspace_index];

              // print diagnostics
              const HalfInt bra_J = sector.bra_subspace().J();
              const HalfInt ket_J = sector.ket_subspace().J();
              std::cout
                << fmt::format("Observable {} bra_J {} ket_J {}",observable_index,bra_J,ket_J)
                << std::endl;
              // std::cout
              //   << mcutils::FormatMatrix(observable_results_matrix,"8.5f")
              //   << std::endl
              //   << std::endl;
            }

        }

      // end timing
      timer_observables.Stop();
      std::cout << fmt::format("  (Observables: {})",timer_observables.ElapsedTime()) << std::endl;

      // results output: observables
      spncci::WriteObservables(
          results_stream,
          observable_sectors,
          observable_results_matrices,
          run_parameters.gex
        );

    }

  // timing stop
  timer_mesh.Stop();
  std::cout << fmt::format("(Mesh master loop: {})",timer_mesh.ElapsedTime()) << std::endl;

  ////////////////////////////////////////////////////////////////
  // termination
  ////////////////////////////////////////////////////////////////
  results_stream.close();

}
